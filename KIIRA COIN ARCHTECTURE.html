<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiira Coin (KRC) Blockchain</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4fc3f7;
            --dark: #1a2639;
            --light: #f0f4f8;
            --success: #4caf50;
            --warning: #ff9800;
            --danger: #f44336;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--light);
            color: var(--dark);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            padding: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        #coin-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        
        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        nav a:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .sidebar {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .sidebar-menu {
            list-style: none;
        }
        
        .sidebar-menu li {
            margin-bottom: 10px;
        }
        
        .sidebar-menu button {
            width: 100%;
            padding: 10px;
            border: none;
            background-color: transparent;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .sidebar-menu button:hover {
            background-color: var(--light);
        }
        
        .sidebar-menu button.active {
            background-color: var(--primary);
            color: white;
        }
        
        .content-area {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .module {
            display: none;
        }
        
        .module.active {
            display: block;
        }
        
        .dashboard-stats {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background-color: var(--light);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-card h3 {
            font-size: 14px;
            color: var(--secondary);
            margin-bottom: 10px;
        }
        
        .stat-card p {
            font-size: 24px;
            font-weight: bold;
            color: var(--primary);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--secondary);
        }
        
        .btn-success {
            background-color: var(--success);
            color: white;
        }
        
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: var(--light);
            font-weight: 600;
        }
        
        tr:hover {
            background-color: rgba(0,0,0,0.02);
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 4px;
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .toast.show {
            opacity: 1;
        }
        
        .toast.success {
            background-color: var(--success);
        }
        
        .toast.error {
            background-color: var(--danger);
        }
        
        .toast.warning {
            background-color: var(--warning);
        }
        
        .admin-only {
            display: none;
        }
        
        .super-admin .admin-only {
            display: block;
        }
        
        .qr-code {
            margin: 20px 0;
            padding: 10px;
            background-color: white;
            display: inline-block;
        }
        
        .node-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-indicator.online {
            background-color: var(--success);
        }
        
        .status-indicator.offline {
            background-color: var(--danger);
        }
        
        .status-indicator.syncing {
            background-color: var(--warning);
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .dashboard-stats {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container header-content">
            <div class="logo">
                <img id="coin-icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48Y2lyY2xlIGN4PSIyNTYiIGN5PSIyNTYiIHI9IjI1NiIgZmlsbD0iIzRhNmZhNSIvPjxjaXJjbGUgY3g9IjI1NiIgY3k9IjI1NiIgcj0iMjAwIiBmaWxsPSIjMTY2MDg4Ii8+PHRleHQgeD0iMjUwIiB5PSIyNzAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMjAiIGZpbGw9IiNmZmYiIHRleHQtYW5jaG9yPSJtaWRkbGUiPktSQzwvdGV4dD48L3N2Zz4=" alt="KRC Logo">
                <h1>Kiira Coin (KRC)</h1>
            </div>
            <nav>
                <ul>
                    <li><a href="#" id="nav-dashboard">Dashboard</a></li>
                    <li><a href="#" id="nav-wallet">Wallet</a></li>
                    <li><a href="#" id="nav-transactions">Transactions</a></li>
                    <li><a href="#" id="nav-nodes">Nodes</a></li>
                    <li class="admin-only"><a href="#" id="nav-admin">Admin</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <div class="container">
        <div class="main-content">
            <div class="sidebar">
                <div class="node-status">
                    <div id="node-status-indicator" class="status-indicator offline"></div>
                    <span id="node-status-text">Offline</span>
                </div>
                <ul class="sidebar-menu">
                    <li><button id="menu-dashboard" class="active">Dashboard</button></li>
                    <li><button id="menu-wallet">Wallet</button></li>
                    <li><button id="menu-send">Send KRC</button></li>
                    <li><button id="menu-receive">Receive KRC</button></li>
                    <li><button id="menu-transactions">Transactions</button></li>
                    <li><button id="menu-rewards">Rewards</button></li>
                    <li><button id="menu-nodes">Nodes</button></li>
                    <li class="admin-only"><button id="menu-admin">Admin Settings</button></li>
                    <li><button id="menu-logout">Logout</button></li>
                </ul>
            </div>
            
            <div class="content-area">
                <!-- Dashboard Module -->
                <div id="dashboard-module" class="module active">
                    <h2>Dashboard</h2>
                    <div class="dashboard-stats">
                        <div class="stat-card">
                            <h3>Your Balance</h3>
                            <p id="dashboard-balance">0 KRC</p>
                        </div>
                        <div class="stat-card">
                            <h3>Network Status</h3>
                            <p id="dashboard-network-status">Offline</p>
                        </div>
                        <div class="stat-card">
                            <h3>Block Height</h3>
                            <p id="dashboard-block-height">0</p>
                        </div>
                        <div class="stat-card">
                            <h3>Connected Peers</h3>
                            <p id="dashboard-peer-count">0</p>
                        </div>
                    </div>
                    
                    <h3>Recent Transactions</h3>
                    <div id="recent-transactions">
                        <p>No recent transactions</p>
                    </div>
                    
                    <div class="admin-only">
                        <h3>Network Overview</h3>
                        <div class="dashboard-stats">
                            <div class="stat-card">
                                <h3>Total Supply</h3>
                                <p id="total-supply">10,000,000 KRC</p>
                            </div>
                            <div class="stat-card">
                                <h3>Circulating Supply</h3>
                                <p id="circulating-supply">0 KRC</p>
                            </div>
                            <div class="stat-card">
                                <h3>Active Wallets</h3>
                                <p id="active-wallets">0</p>
                            </div>
                            <div class="stat-card">
                                <h3>Active Nodes</h3>
                                <p id="active-nodes">0</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Wallet Module -->
                <div id="wallet-module" class="module">
                    <h2>Your Wallet</h2>
                    <div class="form-group">
                        <label>Your KRC Address</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="wallet-address" class="form-control" readonly>
                            <button id="copy-address" class="btn btn-primary">Copy</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Balance</label>
                        <input type="text" id="wallet-balance" class="form-control" readonly>
                    </div>
                    
                    <h3>Wallet Security</h3>
                    <div class="form-group">
                        <label>Backup Wallet</label>
                        <button id="backup-wallet" class="btn btn-primary">Download Backup</button>
                        <p class="small-text">Store this file securely. It contains encrypted wallet information.</p>
                    </div>
                    
                    <div class="form-group">
                        <label>Restore Wallet</label>
                        <input type="file" id="restore-file" class="form-control">
                        <button id="restore-wallet" class="btn btn-primary" style="margin-top: 10px;">Restore Wallet</button>
                    </div>
                    
                    <div class="admin-only">
                        <h3>Wallet Statistics</h3>
                        <div class="form-group">
                            <label>Total Wallets</label>
                            <input type="text" id="total-wallets" class="form-control" readonly>
                        </div>
                    </div>
                </div>
                
                <!-- Send Module -->
                <div id="send-module" class="module">
                    <h2>Send KRC</h2>
                    <div class="form-group">
                        <label>Recipient Address</label>
                        <input type="text" id="send-to" class="form-control" placeholder="KRC...">
                    </div>
                    
                    <div class="form-group">
                        <label>Amount</label>
                        <input type="number" id="send-amount" class="form-control" placeholder="0.00" step="0.00000001">
                    </div>
                    
                    <div class="form-group">
                        <label>Memo (Optional)</label>
                        <input type="text" id="send-memo" class="form-control" placeholder="What's this for?">
                    </div>
                    
                    <div class="form-group">
                        <label>Transaction Fee</label>
                        <input type="text" id="send-fee" class="form-control" value="0.001 KRC" readonly>
                    </div>
                    
                    <button id="send-submit" class="btn btn-primary">Send KRC</button>
                </div>
                
                <!-- Receive Module -->
                <div id="receive-module" class="module">
                    <h2>Receive KRC</h2>
                    <div class="form-group">
                        <label>Your KRC Address</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="receive-address" class="form-control" readonly>
                            <button id="copy-receive-address" class="btn btn-primary">Copy</button>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>QR Code</label>
                        <div id="qr-code" class="qr-code"></div>
                    </div>
                    
                    <div class="form-group">
                        <label>Request Payment</label>
                        <input type="number" id="request-amount" class="form-control" placeholder="Amount (optional)" step="0.00000001">
                        <button id="generate-request" class="btn btn-primary" style="margin-top: 10px;">Generate Payment Request</button>
                    </div>
                    
                    <div id="payment-request" style="display: none;">
                        <h3>Payment Request</h3>
                        <div id="request-qr-code" class="qr-code"></div>
                        <div class="form-group">
                            <label>Request Link</label>
                            <input type="text" id="request-link" class="form-control" readonly>
                            <button id="copy-request-link" class="btn btn-primary" style="margin-top: 10px;">Copy Link</button>
                        </div>
                    </div>
                </div>
                
                <!-- Transactions Module -->
                <div id="transactions-module" class="module">
                    <h2>Transaction History</h2>
                    <div class="form-group">
                        <label>Filter Transactions</label>
                        <select id="tx-filter" class="form-control">
                            <option value="all">All Transactions</option>
                            <option value="sent">Sent</option>
                            <option value="received">Received</option>
                            <option value="rewards">Rewards</option>
                        </select>
                    </div>
                    
                    <div id="transactions-list">
                        <p>No transactions found</p>
                    </div>
                </div>
                
                <!-- Rewards Module -->
                <div id="rewards-module" class="module">
                    <h2>Earn KRC Rewards</h2>
                    
                    <div class="form-group">
                        <label>Your Referral Link</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="referral-link" class="form-control" readonly>
                            <button id="copy-referral-link" class="btn btn-primary">Copy</button>
                        </div>
                        <p class="small-text">Earn 10% of your referral's initial reward when they join using your link.</p>
                    </div>
                    
                    <div class="form-group">
                        <label>Referral Stats</label>
                        <div class="dashboard-stats">
                            <div class="stat-card">
                                <h3>Total Referrals</h3>
                                <p id="total-referrals">0</p>
                            </div>
                            <div class="stat-card">
                                <h3>Earned from Referrals</h3>
                                <p id="referral-earnings">0 KRC</p>
                            </div>
                        </div>
                    </div>
                    
                    <h3>Other Rewards</h3>
                    <div class="dashboard-stats">
                        <div class="stat-card">
                            <h3>Online Presence</h3>
                            <p id="online-rewards">0 KRC</p>
                            <button id="claim-online" class="btn btn-primary" style="margin-top: 10px;">Claim</button>
                        </div>
                        <div class="stat-card">
                            <h3>CAPTCHA Solving</h3>
                            <p id="captcha-rewards">0 KRC</p>
                            <button id="solve-captcha" class="btn btn-primary" style="margin-top: 10px;">Solve CAPTCHA</button>
                        </div>
                    </div>
                </div>
                
                <!-- Nodes Module -->
                <div id="nodes-module" class="module">
                    <h2>Network Nodes</h2>
                    
                    <div class="form-group">
                        <label>Node Status</label>
                        <div id="node-details">
                            <p>Your node is currently offline</p>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Run a Node</label>
                        <button id="start-node" class="btn btn-primary">Start Node</button>
                        <button id="stop-node" class="btn btn-danger" style="display: none;">Stop Node</button>
                        <p class="small-text">Running a node helps secure the network and may earn you rewards.</p>
                    </div>
                    
                    <h3>Connected Peers</h3>
                    <table id="peers-table">
                        <thead>
                            <tr>
                                <th>Peer ID</th>
                                <th>Address</th>
                                <th>Status</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="4">No peers connected</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <div class="admin-only">
                        <h3>Node Configuration</h3>
                        <div class="form-group">
                            <label>Bootstrap Nodes</label>
                            <textarea id="bootstrap-nodes" class="form-control" rows="3"></textarea>
                            <button id="save-bootstrap" class="btn btn-primary" style="margin-top: 10px;">Save Configuration</button>
                        </div>
                    </div>
                </div>
                
                <!-- Admin Module -->
                <div id="admin-module" class="module">
                    <h2>Admin Settings</h2>
                    
                    <div class="form-group">
                        <label>Super Admin Address</label>
                        <input type="text" id="admin-address" class="form-control" readonly>
                    </div>
                    
                    <h3>Token Settings</h3>
                    <div class="form-group">
                        <label>Token Name</label>
                        <input type="text" id="token-name" class="form-control" value="Kiira Coin">
                    </div>
                    
                    <div class="form-group">
                        <label>Token Symbol</label>
                        <input type="text" id="token-symbol" class="form-control" value="KRC">
                    </div>
                    
                    <div class="form-group">
                        <label>Token Icon</label>
                        <input type="file" id="token-icon" class="form-control" accept="image/*">
                        <button id="save-icon" class="btn btn-primary" style="margin-top: 10px;">Save Icon</button>
                    </div>
                    
                    <div class="form-group">
                        <label>Total Supply</label>
                        <input type="text" id="token-supply" class="form-control" value="10,000,000 KRC" readonly>
                    </div>
                    
                    <h3>Reward Settings</h3>
                    <div class="form-group">
                        <label>New User Reward (%)</label>
                        <input type="number" id="new-user-reward" class="form-control" value="10" step="0.1">
                    </div>
                    
                    <div class="form-group">
                        <label>Referral Reward (%)</label>
                        <input type="number" id="referral-reward" class="form-control" value="10" step="0.1">
                    </div>
                    
                    <div class="form-group">
                        <label>Online Presence Reward (per hour)</label>
                        <input type="number" id="online-reward" class="form-control" value="0.1" step="0.01">
                    </div>
                    
                    <div class="form-group">
                        <label>CAPTCHA Reward (per solve)</label>
                        <input type="number" id="captcha-reward" class="form-control" value="0.5" step="0.01">
                    </div>
                    
                    <button id="save-rewards" class="btn btn-primary">Save Reward Settings</button>
                    
                    <h3>Exchange Integration</h3>
                    <div class="form-group">
                        <label>Exchange Rate (KRC/USD)</label>
                        <input type="number" id="exchange-rate" class="form-control" value="0.10" step="0.01">
                    </div>
                    
                    <div class="form-group">
                        <label>CoinGecko API Key</label>
                        <input type="password" id="coingecko-api" class="form-control">
                    </div>
                    
                    <div class="form-group">
                        <label>CoinMarketCap API Key</label>
                        <input type="password" id="coinmarketcap-api" class="form-control">
                    </div>
                    
                    <div class="form-group">
                        <label>Infura Project ID</label>
                        <input type="password" id="infura-api" class="form-control">
                    </div>
                    
                    <button id="save-exchange" class="btn btn-primary">Save Exchange Settings</button>
                    
                    <h3>Network Settings</h3>
                    <div class="form-group">
                        <label>Block Time (seconds)</label>
                        <input type="number" id="block-time" class="form-control" value="60">
                    </div>
                    
                    <div class="form-group">
                        <label>Transaction Fee</label>
                        <input type="number" id="tx-fee" class="form-control" value="0.001" step="0.0001">
                    </div>
                    
                    <button id="save-network" class="btn btn-primary">Save Network Settings</button>
                    
                    <h3>Listing Documents</h3>
                    <div class="form-group">
                        <label>Whitepaper</label>
                        <input type="file" id="whitepaper" class="form-control">
                        <button id="upload-whitepaper" class="btn btn-primary" style="margin-top: 10px;">Upload Whitepaper</button>
                    </div>
                    
                    <div class="form-group">
                        <label>Token Logo (PNG, 256x256)</label>
                        <input type="file" id="logo-upload" class="form-control" accept="image/png">
                        <button id="upload-logo" class="btn btn-primary" style="margin-top: 10px;">Upload Logo</button>
                    </div>
                    
                    <div class="form-group">
                        <label>Submit to Exchanges</label>
                        <button id="submit-coingecko" class="btn btn-primary">Submit to CoinGecko</button>
                        <button id="submit-coinmarketcap" class="btn btn-primary">Submit to CoinMarketCap</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="toast" class="toast"></div>
    
    <script src="https://cdn.jsdelivr.net/npm/libp2p/dist/libp2p.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peer-id/dist/peer-id.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libp2p-bootstrap/dist/libp2p-bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libp2p-webrtc-star/dist/libp2p-webrtc-star.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libp2p-websockets/dist/libp2p-websockets.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libp2p-mplex/dist/libp2p-mplex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libp2p-noise/dist/libp2p-noise.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ipfs/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-sha256/src/sha256.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/elliptic/dist/elliptic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bs58check/dist/bs58check.min.js"></script>
    
    <script>
        // Kiira Coin Blockchain Implementation
        class KiiraCoin {
            constructor() {
                this.dbName = 'KiiraCoinDB';
                this.dbVersion = 1;
                this.currentUser = null;
                this.node = null;
                this.ipfs = null;
                this.ec = new elliptic.ec('secp256k1');
                this.totalSupply = 10000000 * 100000000; // 10 million with 8 decimals
                this.rewardSettings = {
                    newUser: 10, // 10% of remaining supply
                    referral: 10, // 10% of new user reward
                    online: 0.1, // 0.1 KRC per hour
                    captcha: 0.5 // 0.5 KRC per solve
                };
                this.networkSettings = {
                    blockTime: 60, // 60 seconds
                    txFee: 0.001 * 100000000, // 0.001 KRC
                    bootstrapNodes: []
                };
                this.exchangeSettings = {
                    rate: 0.10, // $0.10 per KRC
                    coingeckoApi: '',
                    coinmarketcapApi: '',
                    infuraApi: ''
                };
                this.chain = [];
                this.mempool = [];
                this.peers = new Map();
                this.isSuperAdmin = false;
                this.onlineTimer = null;
                this.captchaQueue = [];
                this.currentCaptcha = null;
                
                this.init();
            }
            
            async init() {
                await this.openDatabase();
                await this.loadSettings();
                await this.checkFirstRun();
                await this.initNetwork();
                this.initUI();
                this.startBackgroundSync();
                this.startOnlineRewardTimer();
            }
            
            async openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('wallets')) {
                            const walletsStore = db.createObjectStore('wallets', { keyPath: 'address' });
                            walletsStore.createIndex('publicKey', 'publicKey', { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            const txStore = db.createObjectStore('transactions', { keyPath: 'hash' });
                            txStore.createIndex('from', 'from', { multiEntry: false });
                            txStore.createIndex('to', 'to', { multiEntry: false });
                            txStore.createIndex('block', 'block', { multiEntry: false });
                        }
                        
                        if (!db.objectStoreNames.contains('blocks')) {
                            db.createObjectStore('blocks', { keyPath: 'height' });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        if (!db.objectStoreNames.contains('peers')) {
                            db.createObjectStore('peers', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('rewards')) {
                            const rewardsStore = db.createObjectStore('rewards', { keyPath: 'id' });
                            rewardsStore.createIndex('user', 'user', { multiEntry: false });
                            rewardsStore.createIndex('type', 'type', { multiEntry: false });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        console.error('Database error:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async loadSettings() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('settings', 'readonly');
                    const store = tx.objectStore('settings');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        const settings = event.target.result;
                        settings.forEach(setting => {
                            if (setting.key === 'rewardSettings') this.rewardSettings = setting.value;
                            if (setting.key === 'networkSettings') this.networkSettings = setting.value;
                            if (setting.key === 'exchangeSettings') this.exchangeSettings = setting.value;
                            if (setting.key === 'bootstrapNodes') this.networkSettings.bootstrapNodes = setting.value;
                        });
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error loading settings:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async saveSettings() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('settings', 'readwrite');
                    const store = tx.objectStore('settings');
                    
                    const requests = [
                        store.put({ key: 'rewardSettings', value: this.rewardSettings }),
                        store.put({ key: 'networkSettings', value: this.networkSettings }),
                        store.put({ key: 'exchangeSettings', value: this.exchangeSettings }),
                        store.put({ key: 'bootstrapNodes', value: this.networkSettings.bootstrapNodes })
                    ];
                    
                    let completed = 0;
                    const checkComplete = () => {
                        completed++;
                        if (completed === requests.length) resolve();
                    };
                    
                    requests.forEach(request => {
                        request.onsuccess = checkComplete;
                        request.onerror = (event) => {
                            console.error('Error saving settings:', event.target.error);
                            reject(event.target.error);
                        };
                    });
                });
            }
            
            async checkFirstRun() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.count();
                    
                    request.onsuccess = (event) => {
                        if (event.target.result === 0) {
                            // First run, create super admin
                            this.createSuperAdmin().then(resolve).catch(reject);
                        } else {
                            // Not first run, check for current user
                            this.loadCurrentUser().then(resolve).catch(reject);
                        }
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error checking first run:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async createSuperAdmin() {
                const keyPair = this.ec.genKeyPair();
                const privateKey = keyPair.getPrivate('hex');
                const publicKey = keyPair.getPublic('hex');
                const address = this.generateAddress(publicKey);
                
                // Super admin gets 50% of total supply
                const initialBalance = Math.floor(this.totalSupply * 0.5);
                
                const wallet = {
                    address,
                    publicKey,
                    encryptedPrivateKey: this.encryptPrivateKey(privateKey, 'superadmin'),
                    balance: initialBalance,
                    isSuperAdmin: true,
                    createdAt: Date.now()
                };
                
                await this.saveWallet(wallet);
                
                // Create genesis block
                const genesisBlock = {
                    height: 0,
                    timestamp: Date.now(),
                    transactions: [],
                    previousHash: '0',
                    hash: this.hash('genesis'),
                    validator: address
                };
                
                await this.saveBlock(genesisBlock);
                this.chain.push(genesisBlock);
                
                this.currentUser = wallet;
                this.isSuperAdmin = true;
                
                // Add initial transaction for super admin
                const genesisTx = {
                    hash: this.hash(`genesis-${address}`),
                    from: 'network',
                    to: address,
                    amount: initialBalance,
                    fee: 0,
                    timestamp: Date.now(),
                    block: 0,
                    memo: 'Genesis allocation'
                };
                
                await this.saveTransaction(genesisTx);
                
                this.showToast('Super admin wallet created successfully', 'success');
            }
            
            async loadCurrentUser() {
                return new Promise((resolve, reject) => {
                    // In a real app, you would have proper authentication
                    // For this demo, we'll just use the first wallet
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result;
                        if (wallets.length > 0) {
                            this.currentUser = wallets[0];
                            this.isSuperAdmin = wallets[0].isSuperAdmin || false;
                            
                            // Load chain
                            this.loadChain().then(resolve).catch(reject);
                        } else {
                            reject(new Error('No wallets found'));
                        }
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error loading current user:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async loadChain() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('blocks', 'readonly');
                    const store = tx.objectStore('blocks');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        this.chain = event.target.result.sort((a, b) => a.height - b.height);
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error loading chain:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            encryptPrivateKey(privateKey, password) {
                // In a real app, use proper encryption like AES
                // This is just a placeholder
                return btoa(privateKey + password);
            }
            
            decryptPrivateKey(encryptedKey, password) {
                // In a real app, use proper decryption
                // This is just a placeholder
                const decrypted = atob(encryptedKey);
                return decrypted.replace(password, '');
            }
            
            generateAddress(publicKey) {
                const hash = sha256(publicKey);
                const bytes = Array.from(Buffer.from(hash, 'hex'));
                const checksum = sha256(hash).substr(0, 8);
                const address = 'KRC' + bs58check.encode(Buffer.from(bytes.concat(Array.from(Buffer.from(checksum, 'hex'))));
                return address;
            }
            
            async saveWallet(wallet) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readwrite');
                    const store = tx.objectStore('wallets');
                    const request = store.put(wallet);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error saving wallet:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async saveBlock(block) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('blocks', 'readwrite');
                    const store = tx.objectStore('blocks');
                    const request = store.put(block);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error saving block:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async saveTransaction(tx) {
                return new Promise((resolve, reject) => {
                    const txStore = this.db.transaction('transactions', 'readwrite');
                    const store = txStore.objectStore('transactions');
                    const request = store.put(tx);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error saving transaction:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async initNetwork() {
                try {
                    // Initialize IPFS
                    this.ipfs = await Ipfs.create({
                        repo: 'kiira-coin-ipfs',
                        config: {
                            Addresses: {
                                Swarm: [
                                    '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',
                                    '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star'
                                ]
                            },
                            Bootstrap: this.networkSettings.bootstrapNodes
                        }
                    });
                    
                    // Initialize libp2p node
                    const peerId = await PeerId.create({ bits: 2048, keyType: 'RSA' });
                    
                    this.node = await Libp2p.create({
                        peerId,
                        modules: {
                            transport: [Websockets, WebRTCStar],
                            streamMuxer: [Mplex],
                            connEncryption: [NOISE],
                            peerDiscovery: [Bootstrap]
                        },
                        config: {
                            peerDiscovery: {
                                bootstrap: {
                                    interval: 60e3,
                                    enabled: true,
                                    list: this.networkSettings.bootstrapNodes
                                }
                            }
                        }
                    });
                    
                    this.node.on('peer:discovery', (peerId) => {
                        console.log('Discovered peer:', peerId.toB58String());
                        this.addPeer(peerId);
                    });
                    
                    this.node.connectionManager.on('peer:connect', (connection) => {
                        console.log('Connected to peer:', connection.remotePeer.toB58String());
                        this.updatePeerStatus(connection.remotePeer, 'connected');
                    });
                    
                    this.node.connectionManager.on('peer:disconnect', (connection) => {
                        console.log('Disconnected from peer:', connection.remotePeer.toB58String());
                        this.updatePeerStatus(connection.remotePeer, 'disconnected');
                    });
                    
                    await this.node.start();
                    console.log('Node started with ID:', this.node.peerId.toB58String());
                    
                    this.updateNodeStatus('online');
                    
                    // Add protocol handlers
                    await this.node.handle('/kiira/1.0.0', async ({ connection, stream }) => {
                        const peerId = connection.remotePeer;
                        console.log('Received connection from:', peerId.toB58String());
                        
                        try {
                            const data = await this.readStream(stream);
                            const message = JSON.parse(data.toString());
                            
                            if (message.type === 'block') {
                                await this.handleNewBlock(message.data);
                            } else if (message.type === 'transaction') {
                                await this.handleNewTransaction(message.data);
                            } else if (message.type === 'request_blocks') {
                                await this.sendBlocks(stream, message.data.fromHeight);
                            }
                        } catch (error) {
                            console.error('Error handling protocol:', error);
                        }
                    });
                    
                } catch (error) {
                    console.error('Error initializing network:', error);
                    this.updateNodeStatus('error');
                }
            }
            
            async addPeer(peerId) {
                const peerInfo = {
                    id: peerId.toB58String(),
                    lastSeen: Date.now(),
                    status: 'discovered'
                };
                
                await this.savePeer(peerInfo);
                this.updateUI();
            }
            
            async updatePeerStatus(peerId, status) {
                const peerB58 = peerId.toB58String();
                const peer = await this.getPeer(peerB58);
                
                if (peer) {
                    peer.status = status;
                    peer.lastSeen = Date.now();
                    await this.savePeer(peer);
                    this.updateUI();
                }
            }
            
            async savePeer(peer) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('peers', 'readwrite');
                    const store = tx.objectStore('peers');
                    const request = store.put(peer);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error saving peer:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getPeer(peerId) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('peers', 'readonly');
                    const store = tx.objectStore('peers');
                    const request = store.get(peerId);
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error('Error getting peer:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getAllPeers() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('peers', 'readonly');
                    const store = tx.objectStore('peers');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => resolve(event.target.result || []);
                    request.onerror = (event) => {
                        console.error('Error getting peers:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async readStream(stream) {
                return new Promise((resolve, reject) => {
                    let data = Buffer.from([]);
                    
                    stream.on('data', (chunk) => {
                        data = Buffer.concat([data, chunk]);
                    });
                    
                    stream.on('end', () => {
                        resolve(data);
                    });
                    
                    stream.on('error', (err) => {
                        reject(err);
                    });
                });
            }
            
            async sendBlocks(stream, fromHeight) {
                const blocks = this.chain.filter(block => block.height >= fromHeight);
                
                for (const block of blocks) {
                    const message = {
                        type: 'block',
                        data: block
                    };
                    
                    await this.writeStream(stream, JSON.stringify(message));
                }
                
                stream.end();
            }
            
            async writeStream(stream, data) {
                return new Promise((resolve, reject) => {
                    stream.write(Buffer.from(data));
                    stream.on('error', reject);
                    stream.on('finish', resolve);
                });
            }
            
            async handleNewBlock(block) {
                // Validate block
                if (!this.validateBlock(block)) {
                    console.error('Invalid block received:', block);
                    return;
                }
                
                // Check if we already have this block
                const existingBlock = this.chain.find(b => b.height === block.height);
                if (existingBlock) {
                    if (existingBlock.hash !== block.hash) {
                        // Handle chain reorganization
                        await this.handleChainReorg(block);
                    }
                    return;
                }
                
                // Add block to chain
                this.chain.push(block);
                await this.saveBlock(block);
                
                // Process transactions in block
                for (const tx of block.transactions) {
                    await this.processTransaction(tx, block.height);
                }
                
                this.showToast(`New block received: #${block.height}`, 'success');
                this.updateUI();
            }
            
            async handleNewTransaction(tx) {
                // Check if we already have this transaction
                const existingTx = await this.getTransaction(tx.hash);
                if (existingTx) return;
                
                // Validate transaction
                if (!this.validateTransaction(tx)) {
                    console.error('Invalid transaction received:', tx);
                    return;
                }
                
                // Add to mempool
                this.mempool.push(tx);
                
                // Broadcast to peers
                this.broadcastTransaction(tx);
                
                this.showToast('New transaction received', 'success');
                this.updateUI();
            }
            
            async handleChainReorg(newBlock) {
                console.log('Chain reorganization detected');
                
                // Find common ancestor
                let forkPoint = this.chain.length - 1;
                while (forkPoint >= 0 && this.chain[forkPoint].hash !== newBlock.previousHash) {
                    forkPoint--;
                }
                
                if (forkPoint < 0) {
                    console.error('No common ancestor found for reorg');
                    return;
                }
                
                // Remove blocks after fork point
                const removedBlocks = this.chain.splice(forkPoint + 1);
                
                // Add new block
                this.chain.push(newBlock);
                await this.saveBlock(newBlock);
                
                // Process transactions in new block
                for (const tx of newBlock.transactions) {
                    await this.processTransaction(tx, newBlock.height);
                }
                
                // Revert transactions from removed blocks
                for (const block of removedBlocks) {
                    for (const tx of block.transactions) {
                        await this.revertTransaction(tx);
                    }
                    
                    // Remove block from DB
                    await this.deleteBlock(block.height);
                }
                
                this.showToast(`Chain reorganized at block ${forkPoint}`, 'warning');
                this.updateUI();
            }
            
            async deleteBlock(height) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('blocks', 'readwrite');
                    const store = tx.objectStore('blocks');
                    const request = store.delete(height);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error deleting block:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getTransaction(hash) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('transactions', 'readonly');
                    const store = tx.objectStore('transactions');
                    const request = store.get(hash);
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error('Error getting transaction:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            validateBlock(block) {
                // Check block structure
                if (!block.height || !block.timestamp || !block.transactions || 
                    !block.previousHash || !block.hash || !block.validator) {
                    return false;
                }
                
                // Check hash
                const blockData = {
                    height: block.height,
                    timestamp: block.timestamp,
                    transactions: block.transactions,
                    previousHash: block.previousHash,
                    validator: block.validator
                };
                
                const calculatedHash = this.hash(JSON.stringify(blockData));
                if (calculatedHash !== block.hash) {
                    return false;
                }
                
                // Check previous hash
                if (block.height > 0) {
                    const prevBlock = this.chain.find(b => b.height === block.height - 1);
                    if (!prevBlock || prevBlock.hash !== block.previousHash) {
                        return false;
                    }
                }
                
                // Validate all transactions
                for (const tx of block.transactions) {
                    if (!this.validateTransaction(tx)) {
                        return false;
                    }
                }
                
                // TODO: Validate validator signature
                
                return true;
            }
            
            validateTransaction(tx) {
                // Check tx structure
                if (!tx.hash || !tx.from || !tx.to || !tx.amount || 
                    typeof tx.fee === 'undefined' || !tx.timestamp || !tx.signature) {
                    return false;
                }
                
                // Check hash
                const txData = {
                    from: tx.from,
                    to: tx.to,
                    amount: tx.amount,
                    fee: tx.fee,
                    timestamp: tx.timestamp,
                    memo: tx.memo || ''
                };
                
                const calculatedHash = this.hash(JSON.stringify(txData));
                if (calculatedHash !== tx.hash) {
                    return false;
                }
                
                // Verify signature
                const senderWallet = this.getWalletByAddress(tx.from);
                if (!senderWallet) return false;
                
                const keyPair = this.ec.keyFromPublic(senderWallet.publicKey, 'hex');
                const verified = keyPair.verify(calculatedHash, tx.signature);
                
                if (!verified) {
                    return false;
                }
                
                // Check balance if it's not a reward transaction
                if (tx.from !== 'network') {
                    const balance = senderWallet.balance;
                    if (balance < tx.amount + tx.fee) {
                        return false;
                    }
                }
                
                return true;
            }
            
            async getWalletByAddress(address) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.get(address);
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error('Error getting wallet:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async processTransaction(tx, blockHeight) {
                // Save transaction
                tx.block = blockHeight;
                await this.saveTransaction(tx);
                
                // Update sender balance (if not a reward transaction)
                if (tx.from !== 'network') {
                    const senderWallet = await this.getWalletByAddress(tx.from);
                    if (senderWallet) {
                        senderWallet.balance -= (tx.amount + tx.fee);
                        await this.saveWallet(senderWallet);
                    }
                }
                
                // Update recipient balance
                const recipientWallet = await this.getWalletByAddress(tx.to);
                if (recipientWallet) {
                    recipientWallet.balance += tx.amount;
                    await this.saveWallet(recipientWallet);
                } else {
                    // Create new wallet if recipient doesn't exist
                    // This would only happen for reward transactions
                    const newWallet = {
                        address: tx.to,
                        publicKey: '', // Will be set when user accesses wallet
                        encryptedPrivateKey: '',
                        balance: tx.amount,
                        isSuperAdmin: false,
                        createdAt: Date.now()
                    };
                    
                    await this.saveWallet(newWallet);
                }
                
                // Update validator balance with fees
                const block = this.chain.find(b => b.height === blockHeight);
                if (block) {
                    const validatorWallet = await this.getWalletByAddress(block.validator);
                    if (validatorWallet) {
                        validatorWallet.balance += tx.fee;
                        await this.saveWallet(validatorWallet);
                    }
                }
                
                // If this is the current user's transaction, update UI
                if (this.currentUser && 
                    (tx.from === this.currentUser.address || tx.to === this.currentUser.address)) {
                    this.updateUI();
                }
            }
            
            async revertTransaction(tx) {
                // Revert sender balance (if not a reward transaction)
                if (tx.from !== 'network') {
                    const senderWallet = await this.getWalletByAddress(tx.from);
                    if (senderWallet) {
                        senderWallet.balance += (tx.amount + tx.fee);
                        await this.saveWallet(senderWallet);
                    }
                }
                
                // Revert recipient balance
                const recipientWallet = await this.getWalletByAddress(tx.to);
                if (recipientWallet) {
                    recipientWallet.balance -= tx.amount;
                    
                    // Delete wallet if balance goes to zero and it's not the current user
                    if (recipientWallet.balance <= 0 && 
                        (!this.currentUser || recipientWallet.address !== this.currentUser.address)) {
                        await this.deleteWallet(recipientWallet.address);
                    } else {
                        await this.saveWallet(recipientWallet);
                    }
                }
                
                // Revert validator fees
                const block = this.chain.find(b => b.height === tx.block);
                if (block) {
                    const validatorWallet = await this.getWalletByAddress(block.validator);
                    if (validatorWallet) {
                        validatorWallet.balance -= tx.fee;
                        await this.saveWallet(validatorWallet);
                    }
                }
                
                // Delete transaction
                await this.deleteTransaction(tx.hash);
            }
            
            async deleteWallet(address) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readwrite');
                    const store = tx.objectStore('wallets');
                    const request = store.delete(address);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error deleting wallet:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async deleteTransaction(hash) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('transactions', 'readwrite');
                    const store = tx.objectStore('transactions');
                    const request = store.delete(hash);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error deleting transaction:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async createTransaction(from, to, amount, memo = '') {
                const txData = {
                    from,
                    to,
                    amount: Math.floor(amount * 100000000), // Convert to satoshis
                    fee: this.networkSettings.txFee,
                    timestamp: Date.now(),
                    memo
                };
                
                const hash = this.hash(JSON.stringify(txData));
                
                // Get sender wallet to sign transaction
                const senderWallet = await this.getWalletByAddress(from);
                if (!senderWallet) {
                    throw new Error('Sender wallet not found');
                }
                
                // Check balance
                if (senderWallet.balance < txData.amount + txData.fee) {
                    throw new Error('Insufficient balance');
                }
                
                // Sign transaction (in a real app, this would be done in a secure environment)
                const privateKey = this.decryptPrivateKey(senderWallet.encryptedPrivateKey, 'password');
                const keyPair = this.ec.keyFromPrivate(privateKey, 'hex');
                const signature = keyPair.sign(hash);
                
                const tx = {
                    ...txData,
                    hash,
                    signature
                };
                
                return tx;
            }
            
            async broadcastTransaction(tx) {
                if (!this.node) return;
                
                const peers = await this.getAllPeers();
                for (const peer of peers) {
                    if (peer.status === 'connected') {
                        try {
                            const peerId = await PeerId.createFromB58String(peer.id);
                            const { stream } = await this.node.dialProtocol(peerId, '/kiira/1.0.0');
                            
                            const message = {
                                type: 'transaction',
                                data: tx
                            };
                            
                            await this.writeStream(stream, JSON.stringify(message));
                            stream.close();
                        } catch (error) {
                            console.error('Error broadcasting to peer:', peer.id, error);
                            this.updatePeerStatus(peerId, 'error');
                        }
                    }
                }
            }
            
            async broadcastBlock(block) {
                if (!this.node) return;
                
                const peers = await this.getAllPeers();
                for (const peer of peers) {
                    if (peer.status === 'connected') {
                        try {
                            const peerId = await PeerId.createFromB58String(peer.id);
                            const { stream } = await this.node.dialProtocol(peerId, '/kiira/1.0.0');
                            
                            const message = {
                                type: 'block',
                                data: block
                            };
                            
                            await this.writeStream(stream, JSON.stringify(message));
                            stream.close();
                        } catch (error) {
                            console.error('Error broadcasting to peer:', peer.id, error);
                            this.updatePeerStatus(peerId, 'error');
                        }
                    }
                }
            }
            
            async mineBlock() {
                if (!this.isSuperAdmin) {
                    throw new Error('Only super admin can mine blocks');
                }
                
                if (this.mempool.length === 0) {
                    this.showToast('No transactions to mine', 'warning');
                    return;
                }
                
                // Select transactions from mempool
                const transactions = this.mempool.slice(0, 10); // Limit to 10 tx per block
                
                // Create new block
                const previousBlock = this.chain[this.chain.length - 1];
                const blockData = {
                    height: previousBlock.height + 1,
                    timestamp: Date.now(),
                    transactions,
                    previousHash: previousBlock.hash,
                    validator: this.currentUser.address
                };
                
                const hash = this.hash(JSON.stringify(blockData));
                const block = {
                    ...blockData,
                    hash
                };
                
                // Process block
                await this.handleNewBlock(block);
                
                // Remove mined transactions from mempool
                this.mempool = this.mempool.filter(tx => !transactions.some(t => t.hash === tx.hash));
                
                // Broadcast block
                await this.broadcastBlock(block);
                
                this.showToast(`New block mined: #${block.height}`, 'success');
            }
            
            async createNewUser(referrer = null) {
                const keyPair = this.ec.genKeyPair();
                const privateKey = keyPair.getPrivate('hex');
                const publicKey = keyPair.getPublic('hex');
                const address = this.generateAddress(publicKey);
                
                // Calculate new user reward (10% of remaining supply)
                const remainingSupply = await this.getRemainingSupply();
                const reward = Math.floor(remainingSupply * (this.rewardSettings.newUser / 100));
                
                // Create wallet
                const wallet = {
                    address,
                    publicKey,
                    encryptedPrivateKey: this.encryptPrivateKey(privateKey, 'password'),
                    balance: reward,
                    isSuperAdmin: false,
                    createdAt: Date.now(),
                    referrer
                };
                
                await this.saveWallet(wallet);
                
                // Create reward transaction
                const rewardTx = {
                    hash: this.hash(`reward-${address}-${Date.now()}`),
                    from: 'network',
                    to: address,
                    amount: reward,
                    fee: 0,
                    timestamp: Date.now(),
                    block: this.chain.length, // Will be included in next block
                    memo: 'New user reward'
                };
                
                this.mempool.push(rewardTx);
                
                // If there's a referrer, create referral reward
                if (referrer) {
                    const referralReward = Math.floor(reward * (this.rewardSettings.referral / 100));
                    
                    const referralTx = {
                        hash: this.hash(`referral-${address}-${Date.now()}`),
                        from: 'network',
                        to: referrer,
                        amount: referralReward,
                        fee: 0,
                        timestamp: Date.now(),
                        block: this.chain.length, // Will be included in next block
                        memo: `Referral reward for ${address}`
                    };
                    
                    this.mempool.push(referralTx);
                }
                
                return wallet;
            }
            
            async getRemainingSupply() {
                const totalCirculating = await this.getTotalCirculating();
                return this.totalSupply - totalCirculating;
            }
            
            async getTotalCirculating() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result;
                        const total = wallets.reduce((sum, wallet) => sum + wallet.balance, 0);
                        resolve(total);
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error getting total circulating:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getWalletCount() {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.count();
                    
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => {
                        console.error('Error getting wallet count:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getTransactionsForAddress(address, filter = 'all') {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('transactions', 'readonly');
                    const store = tx.objectStore('transactions');
                    const index = filter === 'sent' ? 'from' : 
                                filter === 'received' ? 'to' : null;
                    
                    if (index) {
                        const request = store.index(index).getAll(address);
                        
                        request.onsuccess = (event) => {
                            const transactions = event.target.result;
                            resolve(transactions.sort((a, b) => b.timestamp - a.timestamp));
                        };
                        
                        request.onerror = (event) => {
                            console.error('Error getting transactions:', event.target.error);
                            reject(event.target.error);
                        };
                    } else {
                        // Get all transactions involving this address
                        const fromRequest = store.index('from').getAll(address);
                        const toRequest = store.index('to').getAll(address);
                        
                        let fromTxs = [];
                        let toTxs = [];
                        let completed = 0;
                        
                        const checkComplete = () => {
                            completed++;
                            if (completed === 2) {
                                const allTxs = [...fromTxs, ...toTxs];
                                // Remove duplicates
                                const uniqueTxs = allTxs.filter((tx, index, self) =>
                                    index === self.findIndex(t => t.hash === tx.hash)
                                );
                                resolve(uniqueTxs.sort((a, b) => b.timestamp - a.timestamp));
                            }
                        };
                        
                        fromRequest.onsuccess = (event) => {
                            fromTxs = event.target.result;
                            checkComplete();
                        };
                        
                        toRequest.onsuccess = (event) => {
                            toTxs = event.target.result;
                            checkComplete();
                        };
                        
                        fromRequest.onerror = (event) => {
                            console.error('Error getting sent transactions:', event.target.error);
                            reject(event.target.error);
                        };
                        
                        toRequest.onerror = (event) => {
                            console.error('Error getting received transactions:', event.target.error);
                            reject(event.target.error);
                        };
                    }
                });
            }
            
            async getReferralStats(referrer) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('wallets', 'readonly');
                    const store = tx.objectStore('wallets');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result;
                        const referrals = wallets.filter(w => w.referrer === referrer);
                        
                        // Get referral rewards from transactions
                        const txStore = this.db.transaction('transactions', 'readonly');
                        const txRequest = txStore.objectStore('transactions').index('to').getAll(referrer);
                        
                        txRequest.onsuccess = (txEvent) => {
                            const transactions = txEvent.target.result;
                            const referralRewards = transactions
                                .filter(tx => tx.memo.includes('Referral reward'))
                                .reduce((sum, tx) => sum + tx.amount, 0);
                            
                            resolve({
                                totalReferrals: referrals.length,
                                referralRewards
                            });
                        };
                        
                        txRequest.onerror = (txEvent) => {
                            console.error('Error getting referral transactions:', txEvent.target.error);
                            reject(txEvent.target.error);
                        };
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error getting wallets:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getOnlineRewards(address) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('rewards', 'readonly');
                    const store = tx.objectStore('rewards');
                    const request = store.index('user').getAll(address);
                    
                    request.onsuccess = (event) => {
                        const rewards = event.target.result;
                        const onlineRewards = rewards
                            .filter(r => r.type === 'online')
                            .reduce((sum, r) => sum + r.amount, 0);
                        resolve(onlineRewards);
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error getting online rewards:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async getCaptchaRewards(address) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('rewards', 'readonly');
                    const store = tx.objectStore('rewards');
                    const request = store.index('user').getAll(address);
                    
                    request.onsuccess = (event) => {
                        const rewards = event.target.result;
                        const captchaRewards = rewards
                            .filter(r => r.type === 'captcha')
                            .reduce((sum, r) => sum + r.amount, 0);
                        resolve(captchaRewards);
                    };
                    
                    request.onerror = (event) => {
                        console.error('Error getting captcha rewards:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async saveReward(reward) {
                return new Promise((resolve, reject) => {
                    const tx = this.db.transaction('rewards', 'readwrite');
                    const store = tx.objectStore('rewards');
                    const request = store.put(reward);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => {
                        console.error('Error saving reward:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async claimOnlineReward() {
                if (!this.currentUser) return;
                
                // Calculate reward based on online time
                const rewardAmount = Math.floor(this.rewardSettings.online * 100000000); // 0.1 KRC
                
                const rewardTx = {
                    hash: this.hash(`online-${this.currentUser.address}-${Date.now()}`),
                    from: 'network',
                    to: this.currentUser.address,
                    amount: rewardAmount,
                    fee: 0,
                    timestamp: Date.now(),
                    block: this.chain.length, // Will be included in next block
                    memo: 'Online presence reward'
                };
                
                this.mempool.push(rewardTx);
                
                // Save reward record
                const reward = {
                    id: `online-${Date.now()}`,
                    user: this.currentUser.address,
                    type: 'online',
                    amount: rewardAmount,
                    timestamp: Date.now()
                };
                
                await this.saveReward(reward);
                this.showToast('Online reward claimed', 'success');
                this.updateUI();
            }
            
            async generateCaptcha() {
                if (!this.currentUser) return;
                
                // Simple CAPTCHA - in a real app, use a more secure method
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let captcha = '';
                for (let i = 0; i < 6; i++) {
                    captcha += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                
                this.currentCaptcha = {
                    text: captcha,
                    reward: Math.floor(this.rewardSettings.captcha * 100000000), // 0.5 KRC
                    expires: Date.now() + 300000 // 5 minutes
                };
                
                return this.currentCaptcha;
            }
            
            async solveCaptcha(solution) {
                if (!this.currentUser || !this.currentCaptcha) return false;
                
                // Check if CAPTCHA is expired
                if (Date.now() > this.currentCaptcha.expires) {
                    this.showToast('CAPTCHA expired', 'error');
                    this.currentCaptcha = null;
                    return false;
                }
                
                // Check solution
                if (solution.toUpperCase() !== this.currentCaptcha.text) {
                    this.showToast('Incorrect CAPTCHA solution', 'error');
                    return false;
                }
                
                // Create reward transaction
                const rewardTx = {
                    hash: this.hash(`captcha-${this.currentUser.address}-${Date.now()}`),
                    from: 'network',
                    to: this.currentUser.address,
                    amount: this.currentCaptcha.reward,
                    fee: 0,
                    timestamp: Date.now(),
                    block: this.chain.length, // Will be included in next block
                    memo: 'CAPTCHA solving reward'
                };
                
                this.mempool.push(rewardTx);
                
                // Save reward record
                const reward = {
                    id: `captcha-${Date.now()}`,
                    user: this.currentUser.address,
                    type: 'captcha',
                    amount: this.currentCaptcha.reward,
                    timestamp: Date.now()
                };
                
                await this.saveReward(reward);
                this.currentCaptcha = null;
                
                this.showToast('CAPTCHA solved successfully', 'success');
                this.updateUI();
                
                return true;
            }
            
            async startNode() {
                if (!this.node) {
                    await this.initNetwork();
                } else if (!this.node.isStarted()) {
                    await this.node.start();
                }
                
                this.updateNodeStatus('online');
                this.showToast('Node started successfully', 'success');
            }
            
            async stopNode() {
                if (this.node && this.node.isStarted()) {
                    await this.node.stop();
                }
                
                this.updateNodeStatus('offline');
                this.showToast('Node stopped', 'warning');
            }
            
            updateNodeStatus(status) {
                const indicator = document.getElementById('node-status-indicator');
                const statusText = document.getElementById('node-status-text');
                
                indicator.className = 'status-indicator';
                statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                
                switch (status) {
                    case 'online':
                        indicator.classList.add('online');
                        break;
                    case 'offline':
                        indicator.classList.add('offline');
                        break;
                    case 'syncing':
                        indicator.classList.add('syncing');
                        break;
                    case 'error':
                        indicator.classList.add('offline');
                        break;
                }
            }
            
            hash(data) {
                return sha256(data);
            }
            
            formatAmount(amount, decimals = 8) {
                return (amount / 100000000).toFixed(decimals);
            }
            
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = 'toast';
                toast.classList.add(type);
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            initUI() {
                // Set up navigation
                document.getElementById('nav-dashboard').addEventListener('click', () => this.showModule('dashboard'));
                document.getElementById('nav-wallet').addEventListener('click', () => this.showModule('wallet'));
                document.getElementById('nav-transactions').addEventListener('click', () => this.showModule('transactions'));
                document.getElementById('nav-nodes').addEventListener('click', () => this.showModule('nodes'));
                document.getElementById('nav-admin').addEventListener('click', () => this.showModule('admin'));
                
                // Set up menu buttons
                document.getElementById('menu-dashboard').addEventListener('click', () => this.showModule('dashboard'));
                document.getElementById('menu-wallet').addEventListener('click', () => this.showModule('wallet'));
                document.getElementById('menu-send').addEventListener('click', () => this.showModule('send'));
                document.getElementById('menu-receive').addEventListener('click', () => this.showModule('receive'));
                document.getElementById('menu-transactions').addEventListener('click', () => this.showModule('transactions'));
                document.getElementById('menu-rewards').addEventListener('click', () => this.showModule('rewards'));
                document.getElementById('menu-nodes').addEventListener('click', () => this.showModule('nodes'));
                document.getElementById('menu-admin').addEventListener('click', () => this.showModule('admin'));
                document.getElementById('menu-logout').addEventListener('click', () => this.logout());
                
                // Wallet actions
                document.getElementById('copy-address').addEventListener('click', () => this.copyToClipboard('wallet-address'));
                document.getElementById('backup-wallet').addEventListener('click', () => this.backupWallet());
                document.getElementById('restore-wallet').addEventListener('click', () => this.restoreWallet());
                
                // Send actions
                document.getElementById('send-submit').addEventListener('click', () => this.sendTransaction());
                
                // Receive actions
                document.getElementById('copy-receive-address').addEventListener('click', () => this.copyToClipboard('receive-address'));
                document.getElementById('generate-request').addEventListener('click', () => this.generatePaymentRequest());
                document.getElementById('copy-request-link').addEventListener('click', () => this.copyToClipboard('request-link'));
                
                // Rewards actions
                document.getElementById('copy-referral-link').addEventListener('click', () => this.copyToClipboard('referral-link'));
                document.getElementById('claim-online').addEventListener('click', () => this.claimOnlineReward());
                document.getElementById('solve-captcha').addEventListener('click', () => this.showCaptchaModal());
                
                // Nodes actions
                document.getElementById('start-node').addEventListener('click', () => this.startNode());
                document.getElementById('stop-node').addEventListener('click', () => this.stopNode());
                document.getElementById('save-bootstrap').addEventListener('click', () => this.saveBootstrapNodes());
                
                // Admin actions
                document.getElementById('save-icon').addEventListener('click', () => this.saveTokenIcon());
                document.getElementById('save-rewards').addEventListener('click', () => this.saveRewardSettings());
                document.getElementById('save-exchange').addEventListener('click', () => this.saveExchangeSettings());
                document.getElementById('save-network').addEventListener('click', () => this.saveNetworkSettings());
                document.getElementById('upload-whitepaper').addEventListener('click', () => this.uploadWhitepaper());
                document.getElementById('upload-logo').addEventListener('click', () => this.uploadLogo());
                document.getElementById('submit-coingecko').addEventListener('click', () => this.submitToCoinGecko());
                document.getElementById('submit-coinmarketcap').addEventListener('click', () => this.submitToCoinMarketCap());
                
                // Initial UI update
                this.updateUI();
            }
            
            showModule(moduleName) {
                // Hide all modules
                document.querySelectorAll('.module').forEach(module => {
                    module.classList.remove('active');
                });
                
                // Deactivate all menu buttons
                document.querySelectorAll('.sidebar-menu button').forEach(button => {
                    button.classList.remove('active');
                });
                
                // Show selected module
                document.getElementById(`${moduleName}-module`).classList.add('active');
                
                // Activate menu button
                document.getElementById(`menu-${moduleName}`).classList.add('active');
                
                // Update module-specific UI
                switch (moduleName) {
                    case 'dashboard':
                        this.updateDashboard();
                        break;
                    case 'wallet':
                        this.updateWallet();
                        break;
                    case 'receive':
                        this.updateReceive();
                        break;
                    case 'transactions':
                        this.updateTransactions();
                        break;
                    case 'rewards':
                        this.updateRewards();
                        break;
                    case 'nodes':
                        this.updateNodes();
                        break;
                    case 'admin':
                        this.updateAdmin();
                        break;
                }
            }
            
            updateUI() {
                if (!this.currentUser) return;
                
                // Update wallet address display
                document.getElementById('wallet-address').value = this.currentUser.address;
                document.getElementById('receive-address').value = this.currentUser.address;
                
                // Update balance display
                const balance = this.formatAmount(this.currentUser.balance);
                document.getElementById('dashboard-balance').textContent = `${balance} KRC`;
                document.getElementById('wallet-balance').value = `${balance} KRC`;
                
                // Update network status
                const status = this.node && this.node.isStarted() ? 'Online' : 'Offline';
                document.getElementById('dashboard-network-status').textContent = status;
                
                // Update block height
                const blockHeight = this.chain.length > 0 ? this.chain[this.chain.length - 1].height : 0;
                document.getElementById('dashboard-block-height').textContent = blockHeight;
                
                // Update peer count
                this.getAllPeers().then(peers => {
                    const connectedPeers = peers.filter(p => p.status === 'connected').length;
                    document.getElementById('dashboard-peer-count').textContent = connectedPeers;
                });
                
                // Update admin UI visibility
                if (this.isSuperAdmin) {
                    document.body.classList.add('super-admin');
                    
                    // Update admin stats
                    this.getWalletCount().then(count => {
                        document.getElementById('total-wallets').value = count;
                        document.getElementById('active-wallets').textContent = count;
                    });
                    
                    this.getTotalCirculating().then(total => {
                        const formattedTotal = this.formatAmount(total);
                        document.getElementById('circulating-supply').textContent = `${formattedTotal} KRC`;
                    });
                    
                    this.getAllPeers().then(peers => {
                        document.getElementById('active-nodes').textContent = peers.filter(p => p.status === 'connected').length;
                    });
                } else {
                    document.body.classList.remove('super-admin');
                }
            }
            
            updateDashboard() {
                if (!this.currentUser) return;
                
                // Update recent transactions
                this.getTransactionsForAddress(this.currentUser.address, 'all').then(transactions => {
                    const recentTx = transactions.slice(0, 5);
                    const txList = document.getElementById('recent-transactions');
                    
                    if (recentTx.length === 0) {
                        txList.innerHTML = '<p>No recent transactions</p>';
                        return;
                    }
                    
                    let html = '<table><thead><tr><th>Date</th><th>From/To</th><th>Amount</th><th>Memo</th></tr></thead><tbody>';
                    
                    recentTx.forEach(tx => {
                        const date = new Date(tx.timestamp).toLocaleString();
                        const amount = this.formatAmount(tx.amount);
                        const direction = tx.from === this.currentUser.address ? 'To: ' + tx.to : 'From: ' + tx.from;
                        
                        html += `<tr>
                            <td>${date}</td>
                            <td>${direction}</td>
                            <td>${amount} KRC</td>
                            <td>${tx.memo || ''}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    txList.innerHTML = html;
                });
            }
            
            updateWallet() {
                // Generate QR code for wallet address
                const qr = qrcode(0, 'L');
                qr.addData(this.currentUser.address);
                qr.make();
                document.getElementById('qr-code').innerHTML = qr.createImgTag(4);
            }
            
            updateReceive() {
                // Generate QR code for wallet address
                const qr = qrcode(0, 'L');
                qr.addData(this.currentUser.address);
                qr.make();
                document.getElementById('qr-code').innerHTML = qr.createImgTag(4);
            }
            
            updateTransactions() {
                if (!this.currentUser) return;
                
                const filter = document.getElementById('tx-filter').value;
                
                this.getTransactionsForAddress(this.currentUser.address, filter).then(transactions => {
                    const txList = document.getElementById('transactions-list');
                    
                    if (transactions.length === 0) {
                        txList.innerHTML = '<p>No transactions found</p>';
                        return;
                    }
                    
                    let html = '<table><thead><tr><th>Date</th><th>From/To</th><th>Amount</th><th>Status</th><th>Memo</th></tr></thead><tbody>';
                    
                    transactions.forEach(tx => {
                        const date = new Date(tx.timestamp).toLocaleString();
                        const amount = this.formatAmount(tx.amount);
                        const direction = tx.from === this.currentUser.address ? 'To: ' + tx.to : 'From: ' + tx.from;
                        const status = tx.block > 0 ? 'Confirmed' : 'Pending';
                        
                        html += `<tr>
                            <td>${date}</td>
                            <td>${direction}</td>
                            <td>${amount} KRC</td>
                            <td>${status}</td>
                            <td>${tx.memo || ''}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    txList.innerHTML = html;
                });
                
                // Add filter change listener
                document.getElementById('tx-filter').addEventListener('change', () => {
                    this.updateTransactions();
                });
            }
            
            updateRewards() {
                if (!this.currentUser) return;
                
                // Update referral link
                const referralLink = `${window.location.origin}${window.location.pathname}?ref=${this.currentUser.address}`;
                document.getElementById('referral-link').value = referralLink;
                
                // Update referral stats
                this.getReferralStats(this.currentUser.address).then(stats => {
                    document.getElementById('total-referrals').textContent = stats.totalReferrals;
                    document.getElementById('referral-earnings').textContent = this.formatAmount(stats.referralRewards) + ' KRC';
                });
                
                // Update online rewards
                this.getOnlineRewards(this.currentUser.address).then(rewards => {
                    document.getElementById('online-rewards').textContent = this.formatAmount(rewards) + ' KRC';
                });
                
                // Update CAPTCHA rewards
                this.getCaptchaRewards(this.currentUser.address).then(rewards => {
                    document.getElementById('captcha-rewards').textContent = this.formatAmount(rewards) + ' KRC';
                });
            }
            
            updateNodes() {
                this.getAllPeers().then(peers => {
                    const peersTable = document.getElementById('peers-table').querySelector('tbody');
                    
                    if (peers.length === 0) {
                        peersTable.innerHTML = '<tr><td colspan="4">No peers connected</td></tr>';
                        return;
                    }
                    
                    let html = '';
                    
                    peers.forEach(peer => {
                        const lastSeen = new Date(peer.lastSeen).toLocaleString();
                        const statusClass = peer.status === 'connected' ? 'online' : 
                                          peer.status === 'disconnected' ? 'offline' : 'syncing';
                        
                        html += `<tr>
                            <td>${peer.id.substring(0, 8)}...</td>
                            <td>${peer.addresses ? peer.addresses[0] : 'N/A'}</td>
                            <td><span class="status-indicator ${statusClass}"></span> ${peer.status}</td>
                            <td>${lastSeen}</td>
                        </tr>`;
                    });
                    
                    peersTable.innerHTML = html;
                });
                
                // Update bootstrap nodes
                document.getElementById('bootstrap-nodes').value = this.networkSettings.bootstrapNodes.join('\n');
            }
            
            updateAdmin() {
                if (!this.isSuperAdmin) return;
                
                // Update admin address
                document.getElementById('admin-address').value = this.currentUser.address;
                
                // Update reward settings
                document.getElementById('new-user-reward').value = this.rewardSettings.newUser;
                document.getElementById('referral-reward').value = this.rewardSettings.referral;
                document.getElementById('online-reward').value = this.rewardSettings.online;
                document.getElementById('captcha-reward').value = this.rewardSettings.captcha;
                
                // Update exchange settings
                document.getElementById('exchange-rate').value = this.exchangeSettings.rate;
                document.getElementById('coingecko-api').value = this.exchangeSettings.coingeckoApi;
                document.getElementById('coinmarketcap-api').value = this.exchangeSettings.coinmarketcapApi;
                document.getElementById('infura-api').value = this.exchangeSettings.infuraApi;
                
                // Update network settings
                document.getElementById('block-time').value = this.networkSettings.blockTime;
                document.getElementById('tx-fee').value = this.formatAmount(this.networkSettings.txFee);
            }
            
            copyToClipboard(elementId) {
                const element = document.getElementById(elementId);
                element.select();
                document.execCommand('copy');
                
                // Show tooltip
                const originalText = element.value;
                element.value = 'Copied!';
                setTimeout(() => {
                    element.value = originalText;
                }, 2000);
                
                this.showToast('Copied to clipboard', 'success');
            }
            
            async backupWallet() {
                if (!this.currentUser) return;
                
                // Create backup data (without private key)
                const backupData = {
                    address: this.currentUser.address,
                    publicKey: this.currentUser.publicKey,
                    createdAt: this.currentUser.createdAt,
                    balance: this.currentUser.balance
                };
                
                // Create blob and download
                const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `krc-wallet-${this.currentUser.address}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showToast('Wallet backup downloaded', 'success');
            }
            
            async restoreWallet() {
                const fileInput = document.getElementById('restore-file');
                if (!fileInput.files.length) return;
                
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = async (e) => {
                    try {
                        const backupData = JSON.parse(e.target.result);
                        
                        // Check if wallet exists
                        const existingWallet = await this.getWalletByAddress(backupData.address);
                        if (!existingWallet) {
                            throw new Error('Wallet not found in database');
                        }
                        
                        // Update current user
                        this.currentUser = existingWallet;
                        this.updateUI();
                        
                        this.showToast('Wallet restored successfully', 'success');
                    } catch (error) {
                        console.error('Error restoring wallet:', error);
                        this.showToast('Error restoring wallet', 'error');
                    }
                };
                
                reader.readAsText(file);
            }
            
            async sendTransaction() {
                const toAddress = document.getElementById('send-to').value;
                const amount = parseFloat(document.getElementById('send-amount').value);
                const memo = document.getElementById('send-memo').value;
                
                if (!toAddress || !toAddress.startsWith('KRC') || toAddress.length < 10) {
                    this.showToast('Invalid recipient address', 'error');
                    return;
                }
                
                if (isNaN(amount) || amount <= 0) {
                    this.showToast('Invalid amount', 'error');
                    return;
                }
                
                try {
                    const tx = await this.createTransaction(
                        this.currentUser.address,
                        toAddress,
                        amount * 100000000, // Convert to satoshis
                        memo
                    );
                    
                    // Add to mempool
                    this.mempool.push(tx);
                    
                    // Broadcast transaction
                    await this.broadcastTransaction(tx);
                    
                    // Clear form
                    document.getElementById('send-to').value = '';
                    document.getElementById('send-amount').value = '';
                    document.getElementById('send-memo').value = '';
                    
                    this.showToast('Transaction sent successfully', 'success');
                    this.updateUI();
                } catch (error) {
                    console.error('Error sending transaction:', error);
                    this.showToast(error.message, 'error');
                }
            }
            
            generatePaymentRequest() {
                const amount = parseFloat(document.getElementById('request-amount').value);
                
                if (isNaN(amount) {
                    this.showToast('Please enter a valid amount', 'error');
                    return;
                }
                
                const requestData = {
                    address: this.currentUser.address,
                    amount: amount * 100000000, // Convert to satoshis
                    timestamp: Date.now()
                };
                
                const requestString = JSON.stringify(requestData);
                const requestLink = `${window.location.origin}${window.location.pathname}?request=${encodeURIComponent(requestString)}`;
                
                // Generate QR code
                const qr = qrcode(0, 'L');
                qr.addData(requestLink);
                qr.make();
                document.getElementById('request-qr-code').innerHTML = qr.createImgTag(4);
                
                // Update UI
                document.getElementById('request-link').value = requestLink;
                document.getElementById('payment-request').style.display = 'block';
                
                this.showToast('Payment request generated', 'success');
            }
            
            showCaptchaModal() {
                // In a real app, show a modal with CAPTCHA
                // For this demo, we'll just prompt
                this.generateCaptcha().then(captcha => {
                    const solution = prompt(`Please enter the following CAPTCHA: ${captcha.text}`);
                    if (solution) {
                        this.solveCaptcha(solution).then(success => {
                            if (success) {
                                this.updateRewards();
                            }
                        });
                    }
                });
            }
            
            saveBootstrapNodes() {
                const nodesText = document.getElementById('bootstrap-nodes').value;
                const nodes = nodesText.split('\n').filter(node => node.trim() !== '');
                
                this.networkSettings.bootstrapNodes = nodes;
                this.saveSettings().then(() => {
                    this.showToast('Bootstrap nodes saved', 'success');
                    
                    // Restart node with new bootstrap nodes
                    if (this.node && this.node.isStarted()) {
                        this.stopNode().then(() => this.startNode());
                    }
                });
            }
            
            saveTokenIcon() {
                const fileInput = document.getElementById('token-icon');
                if (!fileInput.files.length) return;
                
                const file = fileInput.files[0];
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    document.getElementById('coin-icon').src = e.target.result;
                    this.showToast('Token icon saved', 'success');
                    
                    // In a real app, upload to IPFS
                    // this.uploadToIPFS(file).then(cid => {
                    //     this.tokenIconCID = cid;
                    // });
                };
                
                reader.readAsDataURL(file);
            }
            
            saveRewardSettings() {
                this.rewardSettings = {
                    newUser: parseFloat(document.getElementById('new-user-reward').value),
                    referral: parseFloat(document.getElementById('referral-reward').value),
                    online: parseFloat(document.getElementById('online-reward').value),
                    captcha: parseFloat(document.getElementById('captcha-reward').value)
                };
                
                this.saveSettings().then(() => {
                    this.showToast('Reward settings saved', 'success');
                });
            }
            
            saveExchangeSettings() {
                this.exchangeSettings = {
                    rate: parseFloat(document.getElementById('exchange-rate').value),
                    coingeckoApi: document.getElementById('coingecko-api').value,
                    coinmarketcapApi: document.getElementById('coinmarketcap-api').value,
                    infuraApi: document.getElementById('infura-api').value
                };
                
                this.saveSettings().then(() => {
                    this.showToast('Exchange settings saved', 'success');
                });
            }
            
            saveNetworkSettings() {
                this.networkSettings = {
                    blockTime: parseInt(document.getElementById('block-time').value),
                    txFee: Math.floor(parseFloat(document.getElementById('tx-fee').value) * 100000000),
                    bootstrapNodes: this.networkSettings.bootstrapNodes
                };
                
                this.saveSettings().then(() => {
                    this.showToast('Network settings saved', 'success');
                });
            }
            
            async uploadWhitepaper() {
                const fileInput = document.getElementById('whitepaper');
                if (!fileInput.files.length) return;
                
                const file = fileInput.files[0];
                
                try {
                    // In a real app, upload to IPFS
                    // const cid = await this.uploadToIPFS(file);
                    // this.whitepaperCID = cid;
                    
                    this.showToast('Whitepaper uploaded successfully', 'success');
                } catch (error) {
                    console.error('Error uploading whitepaper:', error);
                    this.showToast('Error uploading whitepaper', 'error');
                }
            }
            
            async uploadLogo() {
                const fileInput = document.getElementById('logo-upload');
                if (!fileInput.files.length) return;
                
                const file = fileInput.files[0];
                
                try {
                    // In a real app, upload to IPFS
                    // const cid = await this.uploadToIPFS(file);
                    // this.logoCID = cid;
                    
                    this.showToast('Logo uploaded successfully', 'success');
                } catch (error) {
                    console.error('Error uploading logo:', error);
                    this.showToast('Error uploading logo', 'error');
                }
            }
            
            async submitToCoinGecko() {
                if (!this.exchangeSettings.coingeckoApi) {
                    this.showToast('CoinGecko API key required', 'error');
                    return;
                }
                
                // In a real app, submit to CoinGecko API
                // const response = await fetch('https://api.coingecko.com/api/v3/coins', {
                //     method: 'POST',
                //     headers: {
                //         'Content-Type': 'application/json',
                //         'x-cg-pro-api-key': this.exchangeSettings.coingeckoApi
                //     },
                //     body: JSON.stringify({
                //         id: 'kiira-coin',
                //         symbol: 'krc',
                //         name: 'Kiira Coin',
                //         platforms: {},
                //         // ... other required fields
                //     })
                // });
                
                this.showToast('Submitted to CoinGecko', 'success');
            }
            
            async submitToCoinMarketCap() {
                if (!this.exchangeSettings.coinmarketcapApi) {
                    this.showToast('CoinMarketCap API key required', 'error');
                    return;
                }
                
                // In a real app, submit to CoinMarketCap
                // This would typically be done via their form
                
                this.showToast('Submitted to CoinMarketCap', 'success');
            }
            
            logout() {
                this.currentUser = null;
                this.isSuperAdmin = false;
                
                // Reload page to reset state
                window.location.reload();
            }
            
            startBackgroundSync() {
                // Sync with network every 30 seconds
                setInterval(() => {
                    if (this.node && this.node.isStarted()) {
                        this.syncWithNetwork();
                    }
                }, 30000);
            }
            
            startOnlineRewardTimer() {
                // Claim online reward every hour
                this.onlineTimer = setInterval(() => {
                    if (this.currentUser) {
                        this.claimOnlineReward();
                    }
                }, 3600000);
            }
            
            async syncWithNetwork() {
                if (!this.node) return;
                
                this.updateNodeStatus('syncing');
                
                try {
                    // Get latest block from peers
                    const peers = await this.getAllPeers();
                    const connectedPeers = peers.filter(p => p.status === 'connected');
                    
                    if (connectedPeers.length === 0) {
                        this.updateNodeStatus('online');
                        return;
                    }
                    
                    // Request blocks from highest peer
                    const peerId = await PeerId.createFromB58String(connectedPeers[0].id);
                    const { stream } = await this.node.dialProtocol(peerId, '/kiira/1.0.0');
                    
                    const message = {
                        type: 'request_blocks',
                        data: {
                            fromHeight: this.chain.length
                        }
                    };
                    
                    await this.writeStream(stream, JSON.stringify(message));
                    
                    // Handle response
                    const data = await this.readStream(stream);
                    const response = JSON.parse(data.toString());
                    
                    if (response.type === 'block') {
                        await this.handleNewBlock(response.data);
                    }
                    
                    this.updateNodeStatus('online');
                } catch (error) {
                    console.error('Error syncing with network:', error);
                    this.updateNodeStatus('error');
                }
            }
            
            async uploadToIPFS(file) {
                if (!this.ipfs) return;
                
                const { cid } = await this.ipfs.add(file);
                return cid.toString();
            }
        }
        
        // Initialize Kiira Coin when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.krc = new KiiraCoin();
            
            // Check for referral or payment request in URL
            const urlParams = new URLSearchParams(window.location.search);
            const ref = urlParams.get('ref');
            const request = urlParams.get('request');
            
            if (ref && window.krc.currentUser && !window.krc.currentUser.isSuperAdmin) {
                // New user with referral
                window.krc.createNewUser(ref).then(() => {
                    window.krc.showToast('Welcome to Kiira Coin! You received your new user reward.', 'success');
                    window.history.replaceState({}, document.title, window.location.pathname);
                });
            } else if (request) {
                // Payment request
                try {
                    const requestData = JSON.parse(decodeURIComponent(request));
                    
                    if (requestData.address && requestData.amount) {
                        // Pre-fill send form
                        document.getElementById('send-to').value = requestData.address;
                        document.getElementById('send-amount').value = window.krc.formatAmount(requestData.amount);
                        window.krc.showModule('send');
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                } catch (error) {
                    console.error('Error parsing payment request:', error);
                }
            }
        });
    </script>
</body>
</html>
