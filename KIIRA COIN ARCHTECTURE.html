<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiira Coin (KRC) Blockchain</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ipfs-http-client/dist/index.min.js"></script>
    <script src="https://unpkg.com/hypercore-crypto@2.3.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4fc3f7;
            --background: #f5f7fa;
            --card: #ffffff;
            --text: #333333;
            --success: #4caf50;
            --warning: #ff9800;
            --error: #f44336;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            padding: 20px 0;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo img {
            height: 40px;
            width: 40px;
            border-radius: 50%;
        }
        
        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        nav a:hover {
            background-color: rgba(255,255,255,0.2);
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
        }
        
        .sidebar {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .sidebar ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .sidebar li {
            margin-bottom: 10px;
        }
        
        .sidebar a {
            display: block;
            padding: 10px;
            color: var(--text);
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .sidebar a:hover, .sidebar a.active {
            background-color: var(--primary);
            color: white;
        }
        
        .main-content {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .card {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .balance-card {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            text-align: center;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .balance-amount {
            font-size: 2.5rem;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: var(--secondary);
        }
        
        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: var(--background);
            font-weight: 500;
        }
        
        tr:hover {
            background-color: rgba(0,0,0,0.02);
        }
        
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .status-success {
            background-color: rgba(76, 175, 80, 0.1);
            color: var(--success);
        }
        
        .status-pending {
            background-color: rgba(255, 152, 0, 0.1);
            color: var(--warning);
        }
        
        .status-error {
            background-color: rgba(244, 67, 54, 0.1);
            color: var(--error);
        }
        
        .badge {
            display: inline-block;
            padding: 3px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            background-color: var(--accent);
            color: white;
        }
        
        .hidden {
            display: none !important;
        }
        
        .admin-only {
            border-left: 4px solid var(--warning);
            padding-left: 10px;
        }
        
        .tab-container {
            margin-bottom: 20px;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom: 2px solid var(--primary);
            font-weight: 500;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .peer-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .peer-status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #ccc;
        }
        
        .peer-status-indicator.connected {
            background-color: var(--success);
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: var(--text);
            color: white;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .toast.success {
            background-color: var(--success);
        }
        
        .toast.error {
            background-color: var(--error);
        }
        
        .toast.warning {
            background-color: var(--warning);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 40px;
            color: #777;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .header-content {
                flex-direction: column;
                gap: 15px;
            }
            
            nav ul {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container header-content">
            <div class="logo">
                <img id="coin-icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptMCA0NDhjLTExMC41IDAtMjAwLTg5LjUtMjAwLTIwMFMxNDUuNSA1NiAyNTYgNTZzMjAwIDg5LjUgMjAwIDIwMC04OS41IDIwMC0yMDAgMjAwWm0xMDEuOC0yNjEuN0wtMjE2LjQgMzYzLjNsLTE3LjYtMTcuNiAzMTkuNC0zMTkuNCAxNy42IDE3LjYtMTk0LjQgMTk0LjR6Ii8+PC9zdmc+" alt="KRC Logo"/>
                <h1>Kiira Coin (KRC)</h1>
            </div>
            <nav>
                <ul>
                    <li><a href="#" class="nav-link" data-section="dashboard">Dashboard</a></li>
                    <li><a href="#" class="nav-link" data-section="wallet">Wallet</a></li>
                    <li><a href="#" class="nav-link" data-section="transactions">Transactions</a></li>
                    <li><a href="#" class="nav-link" data-section="nodes">Nodes</a></li>
                    <li><a href="#" class="nav-link admin-only hidden" data-section="admin">Admin</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="dashboard">
            <div class="sidebar">
                <div class="peer-status">
                    <div class="peer-status-indicator" id="peer-status"></div>
                    <span id="peer-count">0 peers connected</span>
                </div>
                <div id="user-info">
                    <p>Welcome, <span id="username">Guest</span></p>
                    <p>Address: <span id="wallet-address">Not connected</span></p>
                </div>
                <ul>
                    <li><a href="#" class="sidebar-link active" data-section="dashboard">Dashboard</a></li>
                    <li><a href="#" class="sidebar-link" data-section="send">Send KRC</a></li>
                    <li><a href="#" class="sidebar-link" data-section="receive">Receive KRC</a></li>
                    <li><a href="#" class="sidebar-link" data-section="transactions">Transaction History</a></li>
                    <li><a href="#" class="sidebar-link" data-section="earn">Earn KRC</a></li>
                    <li><a href="#" class="sidebar-link" data-section="nodes">Node Setup</a></li>
                    <li><a href="#" class="sidebar-link admin-only hidden" data-section="admin-settings">Admin Settings</a></li>
                    <li><a href="#" class="sidebar-link" data-section="help">Help & Support</a></li>
                    <li><a href="#" id="logout-btn" class="sidebar-link">Logout</a></li>
                </ul>
            </div>

            <div class="main-content">
                <!-- Dashboard Section -->
                <div id="dashboard-section" class="section-content active">
                    <div class="balance-card">
                        <h2>Your KRC Balance</h2>
                        <div class="balance-amount" id="balance">0.00000000 KRC</div>
                        <p>≈ <span id="balance-fiat">$0.00</span></p>
                    </div>
                    
                    <div class="card">
                        <h2>Quick Actions</h2>
                        <div style="display: flex; gap: 15px; margin-top: 15px;">
                            <button class="btn" id="send-btn">Send</button>
                            <button class="btn btn-outline" id="receive-btn">Receive</button>
                            <button class="btn btn-outline" id="earn-btn">Earn KRC</button>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Recent Transactions</h2>
                        <div id="recent-transactions">
                            <p>Loading transactions...</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <h2>Network Status</h2>
                        <div id="network-status">
                            <p>Block Height: <span id="block-height">0</span></p>
                            <p>Network Hashrate: <span id="network-hashrate">0</span> H/s</p>
                            <p>Total Supply: <span id="total-supply">0</span> KRC</p>
                            <p>Circulating Supply: <span id="circulating-supply">0</span> KRC</p>
                        </div>
                    </div>
                </div>

                <!-- Send Section -->
                <div id="send-section" class="section-content">
                    <div class="card">
                        <h2>Send Kiira Coin (KRC)</h2>
                        <form id="send-form">
                            <div class="form-group">
                                <label for="recipient-address">Recipient Address (KRC...)</label>
                                <input type="text" id="recipient-address" placeholder="KRC..." required>
                            </div>
                            <div class="form-group">
                                <label for="send-amount">Amount (KRC)</label>
                                <input type="number" id="send-amount" step="0.00000001" min="0.00000001" required>
                            </div>
                            <div class="form-group">
                                <label for="send-memo">Memo (Optional)</label>
                                <input type="text" id="send-memo" placeholder="What's this payment for?">
                            </div>
                            <div class="form-group">
                                <label for="transaction-fee">Transaction Fee</label>
                                <input type="text" id="transaction-fee" value="0.001 KRC" readonly>
                            </div>
                            <button type="submit" class="btn" id="send-submit-btn">Send Transaction</button>
                        </form>
                    </div>
                </div>

                <!-- Receive Section -->
                <div id="receive-section" class="section-content">
                    <div class="card">
                        <h2>Receive Kiira Coin (KRC)</h2>
                        <div style="text-align: center; margin: 20px 0;">
                            <div id="qr-code" style="display: inline-block; padding: 20px; background: white; margin-bottom: 20px;"></div>
                            <p>Your KRC Address:</p>
                            <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin-bottom: 20px; word-break: break-all;">
                                <strong id="receive-address">Loading address...</strong>
                            </div>
                            <button class="btn" id="copy-address-btn">Copy Address</button>
                            <button class="btn btn-outline" id="share-address-btn">Share Address</button>
                        </div>
                        
                        <div class="card">
                            <h3>Request Payment</h3>
                            <form id="request-payment-form">
                                <div class="form-group">
                                    <label for="request-amount">Amount (KRC)</label>
                                    <input type="number" id="request-amount" step="0.00000001" min="0.00000001">
                                </div>
                                <div class="form-group">
                                    <label for="request-memo">Memo (Optional)</label>
                                    <input type="text" id="request-memo" placeholder="What's this payment for?">
                                </div>
                                <button type="submit" class="btn">Generate Payment Request</button>
                            </form>
                            <div id="payment-request-result" style="margin-top: 20px; display: none;">
                                <p>Share this payment request:</p>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; word-break: break-all;">
                                    <strong id="payment-request-link"></strong>
                                </div>
                                <button class="btn" id="copy-payment-request-btn" style="margin-top: 10px;">Copy Link</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Transactions Section -->
                <div id="transactions-section" class="section-content">
                    <div class="card">
                        <h2>Transaction History</h2>
                        <div class="tab-container">
                            <div class="tabs">
                                <div class="tab active" data-tab="all">All Transactions</div>
                                <div class="tab" data-tab="sent">Sent</div>
                                <div class="tab" data-tab="received">Received</div>
                                <div class="tab" data-tab="pending">Pending</div>
                            </div>
                            
                            <div class="tab-content active" data-tab-content="all">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Type</th>
                                            <th>Amount</th>
                                            <th>Address</th>
                                            <th>Date</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="all-transactions">
                                        <tr><td colspan="6">Loading transactions...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="tab-content" data-tab-content="sent">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Amount</th>
                                            <th>Recipient</th>
                                            <th>Date</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="sent-transactions">
                                        <tr><td colspan="5">Loading transactions...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="tab-content" data-tab-content="received">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Amount</th>
                                            <th>Sender</th>
                                            <th>Date</th>
                                            <th>Status</th>
                                        </tr>
                                    </thead>
                                    <tbody id="received-transactions">
                                        <tr><td colspan="5">Loading transactions...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="tab-content" data-tab-content="pending">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>ID</th>
                                            <th>Type</th>
                                            <th>Amount</th>
                                            <th>Address</th>
                                            <th>Date</th>
                                        </tr>
                                    </thead>
                                    <tbody id="pending-transactions">
                                        <tr><td colspan="5">No pending transactions</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Earn Section -->
                <div id="earn-section" class="section-content">
                    <div class="card">
                        <h2>Earn Kiira Coin (KRC)</h2>
                        <p>Complete tasks to earn KRC tokens:</p>
                        
                        <div class="card" style="margin-top: 20px;">
                            <h3>Referral Program</h3>
                            <p>Earn <span id="referral-percentage">10%</span> of the supply balance for each friend you refer.</p>
                            <div class="form-group">
                                <label>Your Referral Link</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="text" id="referral-link" readonly style="flex: 1;">
                                    <button class="btn" id="copy-referral-link">Copy</button>
                                </div>
                            </div>
                            <div id="referral-stats">
                                <p>Total Referrals: <strong id="total-referrals">0</strong></p>
                                <p>Total Earned: <strong id="referral-earnings">0 KRC</strong></p>
                            </div>
                        </div>
                        
                        <div class="card" style="margin-top: 20px;">
                            <h3>Proof of Availability</h3>
                            <p>Earn KRC by keeping this page open and active. You're currently earning <span id="availability-rate">0.001</span> KRC per minute.</p>
                            <div id="availability-status">
                                <p>Status: <span id="availability-status-text">Inactive</span></p>
                                <p>Time Online: <span id="time-online">0 minutes</span></p>
                                <p>Total Earned: <span id="availability-earnings">0 KRC</span></p>
                            </div>
                            <button class="btn" id="toggle-availability-btn">Start Earning</button>
                        </div>
                        
                        <div class="card" style="margin-top: 20px;">
                            <h3>CAPTCHA Solving</h3>
                            <p>Solve CAPTCHAs to earn KRC. Each solved CAPTCHA earns you <span id="captcha-reward">0.1</span> KRC.</p>
                            <div id="captcha-container" style="margin: 20px 0; text-align: center;">
                                <div id="captcha-display" style="font-size: 24px; letter-spacing: 5px; margin: 20px 0; padding: 20px; background: #f5f5f5; display: inline-block;"></div>
                                <div class="form-group">
                                    <input type="text" id="captcha-input" placeholder="Enter the text above">
                                </div>
                                <button class="btn" id="verify-captcha-btn">Verify CAPTCHA</button>
                                <button class="btn btn-outline" id="new-captcha-btn">New CAPTCHA</button>
                            </div>
                            <div id="captcha-stats">
                                <p>CAPTCHAs Solved: <strong id="captchas-solved">0</strong></p>
                                <p>Total Earned: <strong id="captcha-earnings">0 KRC</strong></p>
                            </div>
                        </div>
                        
                        <div class="card admin-only hidden" style="margin-top: 20px;">
                            <h3>Advertisements</h3>
                            <p>Push advertisements to earn KRC. Each view earns you <span id="ad-reward">0.01</span> KRC.</p>
                            <button class="btn" id="view-ad-btn">View Advertisement</button>
                            <div id="ad-stats" style="margin-top: 20px;">
                                <p>Ads Viewed: <strong id="ads-viewed">0</strong></p>
                                <p>Total Earned: <strong id="ad-earnings">0 KRC</strong></p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Nodes Section -->
                <div id="nodes-section" class="section-content">
                    <div class="card">
                        <h2>Node Setup</h2>
                        <p>Run a KRC node to support the network and earn rewards.</p>
                        
                        <div class="tab-container">
                            <div class="tabs">
                                <div class="tab active" data-tab="node-info">Node Information</div>
                                <div class="tab" data-tab="docker-setup">Docker Setup</div>
                                <div class="tab" data-tab="manual-setup">Manual Setup</div>
                                <div class="tab" data-tab="validator">Validator Node</div>
                            </div>
                            
                            <div class="tab-content active" data-tab-content="node-info">
                                <h3>Node Information</h3>
                                <p>Your node status: <span class="badge" id="node-status">Not running</span></p>
                                <p>Node ID: <code id="node-id">Not available</code></p>
                                <p>Peers connected: <span id="node-peers">0</span></p>
                                <p>Blocks synced: <span id="node-blocks">0</span>/<span id="network-blocks">0</span></p>
                                <p>Uptime: <span id="node-uptime">0</span> minutes</p>
                                <p>Earnings: <span id="node-earnings">0 KRC</span></p>
                                
                                <div style="margin-top: 20px;">
                                    <button class="btn" id="start-node-btn">Start Node</button>
                                    <button class="btn btn-outline" id="stop-node-btn">Stop Node</button>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="docker-setup">
                                <h3>Docker Setup</h3>
                                <p>Run a KRC node with Docker for easy deployment:</p>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 20px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code>docker run -d \
  --name krc-node \
  -p 3000:3000 \
  -p 4001:4001 \
  -p 5001:5001 \
  -p 8080:8080 \
  -v krc-data:/data \
  kiiracoin/krc-node:latest</code></pre>
                                </div>
                                <p>This will start a KRC node with:</p>
                                <ul>
                                    <li>RPC API on port 3000</li>
                                    <li>IPFS on ports 4001, 5001, and 8080</li>
                                    <li>Persistent data storage in a Docker volume</li>
                                </ul>
                                <button class="btn" id="copy-docker-command">Copy Docker Command</button>
                            </div>
                            
                            <div class="tab-content" data-tab-content="manual-setup">
                                <h3>Manual Setup</h3>
                                <p>Follow these steps to set up a KRC node manually:</p>
                                
                                <h4>1. Install Dependencies</h4>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code># Node.js and npm
curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -
sudo apt-get install -y nodejs

# IPFS
wget https://dist.ipfs.io/go-ipfs/v0.12.0/go-ipfs_v0.12.0_linux-amd64.tar.gz
tar -xvzf go-ipfs_v0.12.0_linux-amd64.tar.gz
cd go-ipfs
sudo ./install.sh</code></pre>
                                </div>
                                
                                <h4>2. Clone the KRC Node Repository</h4>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code>git clone https://github.com/kiiracoin/krc-node.git
cd krc-node
npm install</code></pre>
                                </div>
                                
                                <h4>3. Configure the Node</h4>
                                <p>Create a <code>.env</code> file with your configuration:</p>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code>PORT=3000
IPFS_API_PORT=5001
IPFS_GATEWAY_PORT=8080
PEER_MULTIADDR=/ip4/0.0.0.0/tcp/4001
BOOTSTRAP_NODES=/ip4/1.2.3.4/tcp/4001/p2p/QmX1,/ip4/5.6.7.8/tcp/4001/p2p/QmX2</code></pre>
                                </div>
                                
                                <h4>4. Start the Node</h4>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code>npm start</code></pre>
                                </div>
                                
                                <h4>5. (Optional) Run as a Service</h4>
                                <p>Create a systemd service to keep the node running:</p>
                                <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                    <pre style="margin: 0; overflow-x: auto;"><code>[Unit]
Description=KRC Node
After=network.target

[Service]
User=ubuntu
WorkingDirectory=/path/to/krc-node
ExecStart=/usr/bin/npm start
Restart=always

[Install]
WantedBy=multi-user.target</code></pre>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="validator">
                                <h3>Validator Node</h3>
                                <p>Run a validator node to participate in consensus and earn staking rewards.</p>
                                
                                <div id="validator-info">
                                    <p>Minimum stake required: <span id="min-stake">1000</span> KRC</p>
                                    <p>Current staking reward rate: <span id="staking-rate">5%</span> annually</p>
                                    <p>Your current stake: <span id="current-stake">0</span> KRC</p>
                                    <p>Your staking rewards: <span id="staking-rewards">0</span> KRC</p>
                                </div>
                                
                                <form id="stake-form" style="margin-top: 20px;">
                                    <div class="form-group">
                                        <label for="stake-amount">Amount to Stake (KRC)</label>
                                        <input type="number" id="stake-amount" min="0" step="0.00000001">
                                    </div>
                                    <button type="submit" class="btn" id="stake-btn">Stake KRC</button>
                                    <button type="button" class="btn btn-outline" id="unstake-btn">Unstake KRC</button>
                                </form>
                                
                                <div id="validator-instructions" style="margin-top: 30px;">
                                    <h4>Validator Node Setup</h4>
                                    <p>To run a validator node, follow the same steps as a regular node setup, but ensure you have staked the minimum required KRC.</p>
                                    <p>Validator nodes require:</p>
                                    <ul>
                                        <li>Minimum <span id="min-stake2">1000</span> KRC staked</li>
                                        <li>99% uptime</li>
                                        <li>Dedicated IP address</li>
                                        <li>Ports 3000, 4001, 5001, and 8080 open</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Admin Section -->
                <div id="admin-section" class="section-content">
                    <div class="card">
                        <h2>Admin Dashboard</h2>
                        <p>Welcome to the KRC Admin Panel. Here you can manage network settings, token distribution, and integrations.</p>
                        
                        <div class="tab-container">
                            <div class="tabs">
                                <div class="tab active" data-tab="admin-overview">Overview</div>
                                <div class="tab" data-tab="token-settings">Token Settings</div>
                                <div class="tab" data-tab="reward-settings">Reward Settings</div>
                                <div class="tab" data-tab="exchange-integration">Exchange Integration</div>
                                <div class="tab" data-tab="network-settings">Network Settings</div>
                            </div>
                            
                            <div class="tab-content active" data-tab-content="admin-overview">
                                <h3>Network Overview</h3>
                                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">
                                    <div class="card">
                                        <h4>Total Supply</h4>
                                        <p style="font-size: 1.5rem;"><strong id="admin-total-supply">10,000,000</strong> KRC</p>
                                    </div>
                                    <div class="card">
                                        <h4>Circulating Supply</h4>
                                        <p style="font-size: 1.5rem;"><strong id="admin-circulating-supply">0</strong> KRC</p>
                                    </div>
                                    <div class="card">
                                        <h4>Active Nodes</h4>
                                        <p style="font-size: 1.5rem;"><strong id="admin-active-nodes">0</strong></p>
                                    </div>
                                    <div class="card">
                                        <h4>Active Users</h4>
                                        <p style="font-size: 1.5rem;"><strong id="admin-active-users">0</strong></p>
                                    </div>
                                </div>
                                
                                <h3>Recent Network Activity</h3>
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Time</th>
                                            <th>Type</th>
                                            <th>Details</th>
                                            <th>Amount</th>
                                        </tr>
                                    </thead>
                                    <tbody id="admin-activity">
                                        <tr><td colspan="4">Loading activity...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="tab-content" data-tab-content="token-settings">
                                <h3>Token Settings</h3>
                                <form id="token-settings-form">
                                    <div class="form-group">
                                        <label for="token-name">Token Name</label>
                                        <input type="text" id="token-name" value="Kiira Coin" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="token-symbol">Token Symbol</label>
                                        <input type="text" id="token-symbol" value="KRC" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="token-decimals">Decimals</label>
                                        <input type="number" id="token-decimals" value="8" min="0" max="18" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="token-icon">Token Icon</label>
                                        <input type="file" id="token-icon" accept="image/*">
                                        <p class="help-text">Upload a square image (recommended 256x256 pixels)</p>
                                    </div>
                                    <div class="form-group">
                                        <label for="token-description">Token Description</label>
                                        <textarea id="token-description" rows="4">Kiira Coin is a lightweight blockchain with proof-of-stake consensus, designed for microtransactions and rewards.</textarea>
                                    </div>
                                    <button type="submit" class="btn">Save Token Settings</button>
                                </form>
                                
                                <div class="card" style="margin-top: 30px;">
                                    <h3>Token Distribution</h3>
                                    <form id="token-distribution-form">
                                        <div class="form-group">
                                            <label for="distribution-address">Address</label>
                                            <input type="text" id="distribution-address" placeholder="KRC..." required>
                                        </div>
                                        <div class="form-group">
                                            <label for="distribution-amount">Amount (KRC)</label>
                                            <input type="number" id="distribution-amount" step="0.00000001" min="0.00000001" required>
                                        </div>
                                        <div class="form-group">
                                            <label for="distribution-memo">Memo</label>
                                            <input type="text" id="distribution-memo" placeholder="Reason for distribution">
                                        </div>
                                        <button type="submit" class="btn">Distribute Tokens</button>
                                    </form>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="reward-settings">
                                <h3>Reward Settings</h3>
                                <form id="reward-settings-form">
                                    <div class="form-group">
                                        <label for="referral-reward">Referral Reward (%)</label>
                                        <input type="number" id="referral-reward" value="10" min="0" max="100" step="0.1" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="availability-reward">Online Presence Reward (KRC per minute)</label>
                                        <input type="number" id="availability-reward" value="0.001" min="0" step="0.00000001" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="captcha-reward">CAPTCHA Reward (KRC per CAPTCHA)</label>
                                        <input type="number" id="captcha-reward" value="0.1" min="0" step="0.00000001" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="ad-reward">Ad View Reward (KRC per ad)</label>
                                        <input type="number" id="ad-reward" value="0.01" min="0" step="0.00000001" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="staking-reward">Staking Reward (% annually)</label>
                                        <input type="number" id="staking-reward" value="5" min="0" max="100" step="0.1" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="min-stake-reward">Minimum Stake for Validator (KRC)</label>
                                        <input type="number" id="min-stake-reward" value="1000" min="0" step="1" required>
                                    </div>
                                    <button type="submit" class="btn">Save Reward Settings</button>
                                </form>
                            </div>
                            
                            <div class="tab-content" data-tab-content="exchange-integration">
                                <h3>Exchange Integration</h3>
                                <p>Configure API keys and settings for exchange listings and integrations.</p>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>CoinGecko</h4>
                                    <form id="coingecko-form">
                                        <div class="form-group">
                                            <label for="coingecko-api-key">API Key</label>
                                            <input type="password" id="coingecko-api-key" placeholder="Enter your API key">
                                        </div>
                                        <div class="form-group">
                                            <label for="coingecko-coin-id">Coin ID</label>
                                            <input type="text" id="coingecko-coin-id" placeholder="kiira-coin">
                                        </div>
                                        <button type="submit" class="btn">Save CoinGecko Settings</button>
                                        <button type="button" class="btn btn-outline" id="submit-coingecko-btn">Submit to CoinGecko</button>
                                    </form>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>CoinMarketCap</h4>
                                    <form id="coinmarketcap-form">
                                        <div class="form-group">
                                            <label for="coinmarketcap-api-key">API Key</label>
                                            <input type="password" id="coinmarketcap-api-key" placeholder="Enter your API key">
                                        </div>
                                        <div class="form-group">
                                            <label for="coinmarketcap-coin-id">Coin ID</label>
                                            <input type="text" id="coinmarketcap-coin-id" placeholder="12345">
                                        </div>
                                        <button type="submit" class="btn">Save CoinMarketCap Settings</button>
                                        <button type="button" class="btn btn-outline" id="submit-coinmarketcap-btn">Submit to CoinMarketCap</button>
                                    </form>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>DexTools</h4>
                                    <form id="dextools-form">
                                        <div class="form-group">
                                            <label for="dextools-api-key">API Key</label>
                                            <input type="password" id="dextools-api-key" placeholder="Enter your API key">
                                        </div>
                                        <div class="form-group">
                                            <label for="dextools-pair-address">Pair Address</label>
                                            <input type="text" id="dextools-pair-address" placeholder="0x...">
                                        </div>
                                        <button type="submit" class="btn">Save DexTools Settings</button>
                                    </form>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Exchange Rate API</h4>
                                    <form id="exchange-rate-form">
                                        <div class="form-group">
                                            <label for="exchange-rate-provider">Provider</label>
                                            <select id="exchange-rate-provider">
                                                <option value="cryptocompare">CryptoCompare</option>
                                                <option value="coingecko">CoinGecko</option>
                                                <option value="coinmarketcap">CoinMarketCap</option>
                                            </select>
                                        </div>
                                        <div class="form-group">
                                            <label for="exchange-rate-api-key">API Key</label>
                                            <input type="password" id="exchange-rate-api-key" placeholder="Enter your API key">
                                        </div>
                                        <button type="submit" class="btn">Save Exchange Rate Settings</button>
                                    </form>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Listing Requirements</h4>
                                    <p>Documents needed for exchange listings:</p>
                                    <ul>
                                        <li>Token logo (PNG, 256x256)</li>
                                        <li>Token description</li>
                                        <li>Official website URL</li>
                                        <li>Social media links</li>
                                        <li>Whitepaper (optional)</li>
                                    </ul>
                                    <button class="btn" id="generate-listing-package">Generate Listing Package</button>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="network-settings">
                                <h3>Network Settings</h3>
                                <form id="network-settings-form">
                                    <div class="form-group">
                                        <label for="block-time">Block Time (seconds)</label>
                                        <input type="number" id="block-time" value="60" min="1" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="transaction-fee-setting">Transaction Fee (KRC)</label>
                                        <input type="number" id="transaction-fee-setting" value="0.001" min="0" step="0.00000001" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="bootstrap-nodes">Bootstrap Nodes (comma separated)</label>
                                        <textarea id="bootstrap-nodes" rows="4" required>/ip4/1.2.3.4/tcp/4001/p2p/QmX1,/ip4/5.6.7.8/tcp/4001/p2p/QmX2</textarea>
                                    </div>
                                    <div class="form-group">
                                        <label for="max-peers">Maximum Peers</label>
                                        <input type="number" id="max-peers" value="50" min="1" required>
                                    </div>
                                    <div class="form-group">
                                        <label for="difficulty-adjustment">Difficulty Adjustment Interval (blocks)</label>
                                        <input type="number" id="difficulty-adjustment" value="2016" min="1" required>
                                    </div>
                                    <button type="submit" class="btn">Save Network Settings</button>
                                </form>
                                
                                <div class="card" style="margin-top: 30px;">
                                    <h3>Network Maintenance</h3>
                                    <div style="display: flex; gap: 15px; margin-top: 15px;">
                                        <button class="btn" id="export-chain-btn">Export Blockchain Data</button>
                                        <button class="btn btn-outline" id="import-chain-btn">Import Blockchain Data</button>
                                        <button class="btn btn-outline" id="reset-chain-btn">Reset Blockchain</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Help Section -->
                <div id="help-section" class="section-content">
                    <div class="card">
                        <h2>Help & Support</h2>
                        
                        <div class="tab-container">
                            <div class="tabs">
                                <div class="tab active" data-tab="faq">FAQ</div>
                                <div class="tab" data-tab="guides">Guides</div>
                                <div class="tab" data-tab="support">Support</div>
                                <div class="tab" data-tab="developer">Developer</div>
                            </div>
                            
                            <div class="tab-content active" data-tab-content="faq">
                                <h3>Frequently Asked Questions</h3>
                                
                                <div class="faq-item">
                                    <h4>What is Kiira Coin (KRC)?</h4>
                                    <p>Kiira Coin is a lightweight blockchain with proof-of-stake consensus, designed for microtransactions and rewards. It uses minimal resources compared to traditional blockchains like Bitcoin.</p>
                                </div>
                                
                                <div class="faq-item">
                                    <h4>How do I earn KRC?</h4>
                                    <p>You can earn KRC through several methods:
                                        <ul>
                                            <li>Referral program - earn 10% of the supply balance for each friend you refer</li>
                                            <li>Proof of availability - earn KRC by keeping the wallet open and active</li>
                                            <li>CAPTCHA solving - solve CAPTCHAs to earn KRC</li>
                                            <li>Running a node - support the network and earn staking rewards</li>
                                        </ul>
                                    </p>
                                </div>
                                
                                <div class="faq-item">
                                    <h4>How do transactions work?</h4>
                                    <p>Transactions are processed on the KRC blockchain with an average block time of 60 seconds. Each transaction has a small fee (currently 0.001 KRC) to prevent spam.</p>
                                </div>
                                
                                <div class="faq-item">
                                    <h4>What's the total supply of KRC?</h4>
                                    <p>The total supply is fixed at 10,000,000 KRC. New coins are distributed through rewards and gradually released into circulation.</p>
                                </div>
                                
                                <div class="faq-item">
                                    <h4>How do I run a node?</h4>
                                    <p>You can run a node using Docker (recommended) or manually. See the "Node Setup" section for detailed instructions.</p>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="guides">
                                <h3>Guides</h3>
                                
                                <div class="card">
                                    <h4>Getting Started with KRC</h4>
                                    <ol>
                                        <li>Create a wallet by signing up</li>
                                        <li>Secure your account with a strong password</li>
                                        <li>Start earning KRC through referrals, availability, or CAPTCHAs</li>
                                        <li>Send and receive KRC with other users</li>
                                        <li>Consider running a node to support the network</li>
                                    </ol>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Securing Your Wallet</h4>
                                    <ul>
                                        <li>Never share your private key or password</li>
                                        <li>Enable two-factor authentication if available</li>
                                        <li>Regularly back up your wallet</li>
                                        <li>Use a strong, unique password</li>
                                        <li>Be cautious of phishing attempts</li>
                                    </ul>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Running a Validator Node</h4>
                                    <ol>
                                        <li>Stake the minimum required KRC (currently 1000 KRC)</li>
                                        <li>Set up a node using Docker or manual installation</li>
                                        <li>Ensure your node has 99% uptime</li>
                                        <li>Keep your node software updated</li>
                                        <li>Monitor your node's performance</li>
                                    </ol>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="support">
                                <h3>Support</h3>
                                <p>If you need help with Kiira Coin, please contact us through one of these channels:</p>
                                
                                <div class="card">
                                    <h4>Community Support</h4>
                                    <p>Join our community for help and discussions:</p>
                                    <ul>
                                        <li>Telegram: <a href="#" id="telegram-link">t.me/kiiracoin</a></li>
                                        <li>Discord: <a href="#" id="discord-link">discord.gg/kiiracoin</a></li>
                                        <li>Twitter: <a href="#" id="twitter-link">@kiiracoin</a></li>
                                    </ul>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Report an Issue</h4>
                                    <p>Found a bug or have a technical issue?</p>
                                    <form id="support-form">
                                        <div class="form-group">
                                            <label for="support-subject">Subject</label>
                                            <input type="text" id="support-subject" required>
                                        </div>
                                        <div class="form-group">
                                            <label for="support-message">Message</label>
                                            <textarea id="support-message" rows="5" required></textarea>
                                        </div>
                                        <div class="form-group">
                                            <label for="support-email">Your Email (optional)</label>
                                            <input type="email" id="support-email">
                                        </div>
                                        <button type="submit" class="btn">Send Message</button>
                                    </form>
                                </div>
                            </div>
                            
                            <div class="tab-content" data-tab-content="developer">
                                <h3>Developer Resources</h3>
                                <p>Resources for developers looking to build on Kiira Coin:</p>
                                
                                <div class="card">
                                    <h4>API Documentation</h4>
                                    <p>The KRC API allows you to interact with the blockchain:</p>
                                    <ul>
                                        <li><strong>RPC Endpoint:</strong> <code>http://localhost:3000/rpc</code> (for local nodes)</li>
                                        <li><strong>Network Endpoint:</strong> <code>https://api.kiiracoin.com/rpc</code></li>
                                    </ul>
                                    <p>Example API calls:</p>
                                    <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                        <pre style="margin: 0; overflow-x: auto;"><code>// Get balance
{
  "jsonrpc": "2.0",
  "method": "getBalance",
  "params": ["KRC..."],
  "id": 1
}

// Send transaction
{
  "jsonrpc": "2.0",
  "method": "sendTransaction",
  "params": [{
    "from": "KRC...",
    "to": "KRC...",
    "amount": "1.00000000",
    "memo": "Test transaction"
  }],
  "id": 2
}</code></pre>
                                    </div>
                                    <button class="btn" id="download-api-docs">Download API Documentation</button>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Integration Code</h4>
                                    <p>HTML/JavaScript code to integrate KRC payments into your website:</p>
                                    <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                        <pre style="margin: 0; overflow-x: auto;"><code>&lt;!-- KRC Payment Button --&gt;
&lt;button id="krc-pay-button" data-amount="1.00" data-memo="Payment for services"&gt;
  Pay with KRC
&lt;/button&gt;

&lt;script src="https://wallet.kiiracoin.com/integration.js"&gt;&lt;/script&gt;
&lt;script&gt;
  document.getElementById('krc-pay-button').addEventListener('click', function() {
    KRCpay({
      amount: this.getAttribute('data-amount'),
      memo: this.getAttribute('data-memo'),
      onSuccess: function(txHash) {
        alert('Payment successful! Transaction ID: ' + txHash);
      },
      onError: function(error) {
        alert('Payment failed: ' + error);
      }
    });
  });
&lt;/script&gt;</code></pre>
                                    </div>
                                    <button class="btn" id="copy-integration-code">Copy Integration Code</button>
                                </div>
                                
                                <div class="card" style="margin-top: 20px;">
                                    <h4>Smart Contracts</h4>
                                    <p>KRC supports simple smart contracts for advanced functionality:</p>
                                    <div style="background: #f5f5f5; padding: 15px; border-radius: 4px; margin: 10px 0;">
                                        <pre style="margin: 0; overflow-x: auto;"><code>// Example KRC smart contract
contract SimpleEscrow {
  address public buyer;
  address public seller;
  uint public amount;
  bool public released;
  
  constructor(address _seller) payable {
    buyer = msg.sender;
    seller = _seller;
    amount = msg.value;
    released = false;
  }
  
  function release() public {
    require(msg.sender == buyer, "Only buyer can release funds");
    require(!released, "Funds already released");
    payable(seller).transfer(amount);
    released = true;
  }
  
  function cancel() public {
    require(msg.sender == buyer, "Only buyer can cancel");
    require(!released, "Funds already released");
    payable(buyer).transfer(amount);
    released = true;
  }
}</code></pre>
                                    </div>
                                    <p>Smart contracts are executed by validator nodes and require a gas fee.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="login-modal" class="modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div class="card" style="width: 100%; max-width: 400px;">
            <h2>Welcome to Kiira Coin</h2>
            <form id="login-form">
                <div class="form-group">
                    <label for="login-username">Username</label>
                    <input type="text" id="login-username" required>
                </div>
                <div class="form-group">
                    <label for="login-password">Password</label>
                    <input type="password" id="login-password" required>
                </div>
                <button type="submit" class="btn">Login</button>
                <p style="text-align: center; margin-top: 15px;">Don't have an account? <a href="#" id="show-signup">Sign up</a></p>
            </form>
            
            <form id="signup-form" style="display: none;">
                <div class="form-group">
                    <label for="signup-username">Username</label>
                    <input type="text" id="signup-username" required>
                </div>
                <div class="form-group">
                    <label for="signup-password">Password</label>
                    <input type="password" id="signup-password" required>
                </div>
                <div class="form-group">
                    <label for="signup-confirm-password">Confirm Password</label>
                    <input type="password" id="signup-confirm-password" required>
                </div>
                <div class="form-group">
                    <label for="signup-referral">Referral Code (optional)</label>
                    <input type="text" id="signup-referral">
                </div>
                <button type="submit" class="btn">Create Account</button>
                <p style="text-align: center; margin-top: 15px;">Already have an account? <a href="#" id="show-login">Login</a></p>
            </form>
        </div>
    </div>

    <div id="toast" class="toast"></div>

    <footer>
        <p>© 2023 Kiira Coin. All rights reserved.</p>
        <p>KRC is a decentralized cryptocurrency powered by its community.</p>
    </footer>

    <script>
        // Kiira Coin Blockchain Implementation
        class KiiraCoin {
            constructor() {
                this.dbName = 'KiiraCoinDB';
                this.dbVersion = 1;
                this.totalSupply = 10000000; // 10 million KRC
                this.blockTime = 60; // 60 seconds
                this.transactionFee = 0.001; // 0.001 KRC
                this.rewardSettings = {
                    referral: 10, // 10% of supply balance
                    availability: 0.001, // KRC per minute
                    captcha: 0.1, // KRC per CAPTCHA
                    ad: 0.01, // KRC per ad view
                    staking: 5 // 5% annually
                };
                this.minStake = 1000; // Minimum stake for validator
                this.peers = [];
                this.nodeId = null;
                this.ipfs = null;
                this.hypercore = null;
                this.chain = null;
                this.isSuperAdmin = false;
                this.currentUser = null;
                this.availabilityInterval = null;
                this.captchaText = '';
                this.init();
            }
            
            async init() {
                // Initialize database
                await this.initDB();
                
                // Check if this is the first user (super admin)
                const users = await this.getAllUsers();
                if (users.length === 0) {
                    // This is the first run, initialize blockchain
                    await this.initializeBlockchain();
                }
                
                // Initialize networking
                await this.initNetwork();
                
                // Check if user is logged in
                await this.checkAuth();
                
                // Start background sync
                this.syncWithNetwork();
                
                // Start availability rewards if enabled
                this.startAvailabilityRewards();
                
                // Update UI
                this.updateUI();
            }
            
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores
                        if (!db.objectStoreNames.contains('blocks')) {
                            db.createObjectStore('blocks', { keyPath: 'height' });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            db.createObjectStore('transactions', { keyPath: 'hash' });
                        }
                        
                        if (!db.objectStoreNames.contains('wallets')) {
                            db.createObjectStore('wallets', { keyPath: 'address' });
                        }
                        
                        if (!db.objectStoreNames.contains('users')) {
                            db.createObjectStore('users', { keyPath: 'username' });
                        }
                        
                        if (!db.objectStoreNames.contains('peers')) {
                            db.createObjectStore('peers', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        if (!db.objectStoreNames.contains('pendingTransactions')) {
                            db.createObjectStore('pendingTransactions', { keyPath: 'hash' });
                        }
                        
                        if (!db.objectStoreNames.contains('stakes')) {
                            db.createObjectStore('stakes', { keyPath: 'address' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        console.error('Database error:', event.target.error);
                        reject(event.target.error);
                    };
                });
            }
            
            async initializeBlockchain() {
                // Create genesis block
                const genesisBlock = {
                    height: 0,
                    timestamp: Date.now(),
                    transactions: [],
                    previousHash: '0',
                    hash: this.calculateBlockHash(0, '0', [], Date.now()),
                    validator: null,
                    signature: null
                };
                
                await this.addBlock(genesisBlock);
                
                // Initialize settings
                await this.setSetting('totalSupply', this.totalSupply);
                await this.setSetting('circulatingSupply', 0);
                await this.setSetting('rewardSettings', this.rewardSettings);
                await this.setSetting('minStake', this.minStake);
                await this.setSetting('blockTime', this.blockTime);
                await this.setSetting('transactionFee', this.transactionFee);
                await this.setSetting('bootstrapNodes', [
                    '/ip4/1.2.3.4/tcp/4001/p2p/QmX1',
                    '/ip4/5.6.7.8/tcp/4001/p2p/QmX2'
                ]);
            }
            
            async initNetwork() {
                try {
                    // Initialize IPFS
                    this.ipfs = await IpfsHttpClient.create({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });
                    
                    // Initialize Hypercore/DAT for peer-to-peer
                    this.hypercore = new HypercoreCrypto();
                    this.nodeId = this.hypercore.keyPair().publicKey.toString('hex');
                    
                    // Load peers from DB
                    this.peers = await this.getAllPeers();
                    
                    // Connect to bootstrap nodes
                    const bootstrapNodes = await this.getSetting('bootstrapNodes') || [];
                    for (const node of bootstrapNodes) {
                        await this.connectToPeer(node);
                    }
                    
                    // Start peer discovery
                    this.discoverPeers();
                    
                    console.log('Network initialized with node ID:', this.nodeId);
                } catch (error) {
                    console.error('Network initialization error:', error);
                    this.showToast('Failed to initialize network. Running in offline mode.', 'error');
                }
            }
            
            async discoverPeers() {
                try {
                    // Query DHT for peers
                    const peers = await this.ipfs.dht.findProvs(this.hypercore.keyPair().publicKey);
                    for (const peer of peers) {
                        if (!this.peers.some(p => p.id === peer.id)) {
                            await this.addPeer(peer);
                        }
                    }
                    
                    // Update UI
                    this.updatePeerStatus();
                    
                    // Continue discovery
                    setTimeout(() => this.discoverPeers(), 30000);
                } catch (error) {
                    console.error('Peer discovery error:', error);
                    setTimeout(() => this.discoverPeers(), 60000);
                }
            }
            
            async connectToPeer(multiaddr) {
                try {
                    const peer = await this.ipfs.swarm.connect(multiaddr);
                    await this.addPeer(peer);
                    return true;
                } catch (error) {
                    console.error('Failed to connect to peer:', multiaddr, error);
                    return false;
                }
            }
            
            async addPeer(peer) {
                if (!this.peers.some(p => p.id === peer.id)) {
                    this.peers.push(peer);
                    await this.savePeer(peer);
                    this.updatePeerStatus();
                }
            }
            
            async savePeer(peer) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readwrite');
                    const store = transaction.objectStore('peers');
                    const request = store.put(peer);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getAllPeers() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readonly');
                    const store = transaction.objectStore('peers');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async syncWithNetwork() {
                try {
                    // Get latest block from network
                    const latestBlock = await this.getLatestBlockFromNetwork();
                    if (latestBlock) {
                        const localHeight = await this.getBlockHeight();
                        if (latestBlock.height > localHeight) {
                            // We're behind, sync blocks
                            await this.syncBlocks(localHeight + 1, latestBlock.height);
                        }
                    }
                    
                    // Broadcast pending transactions
                    await this.broadcastPendingTransactions();
                    
                    // Continue syncing
                    setTimeout(() => this.syncWithNetwork(), 10000);
                } catch (error) {
                    console.error('Sync error:', error);
                    setTimeout(() => this.syncWithNetwork(), 30000);
                }
            }
            
            async getLatestBlockFromNetwork() {
                try {
                    // Query peers for their latest block
                    for (const peer of this.peers) {
                        try {
                            const response = await this.queryPeer(peer, 'getLatestBlock');
                            if (response && response.height) {
                                return response;
                            }
                        } catch (error) {
                            console.error('Error querying peer:', peer.id, error);
                        }
                    }
                    return null;
                } catch (error) {
                    console.error('Error getting latest block from network:', error);
                    return null;
                }
            }
            
            async queryPeer(peer, method, params = []) {
                // In a real implementation, this would use libp2p or similar to query peers
                // For this demo, we'll simulate it
                return new Promise((resolve) => {
                    setTimeout(() => {
                        if (method === 'getLatestBlock') {
                            resolve({
                                height: 100,
                                hash: '0000000000000000000000000000000000000000000000000000000000000000',
                                timestamp: Date.now()
                            });
                        } else {
                            resolve(null);
                        }
                    }, 500);
                });
            }
            
            async syncBlocks(startHeight, endHeight) {
                console.log(`Syncing blocks from ${startHeight} to ${endHeight}`);
                for (let height = startHeight; height <= endHeight; height++) {
                    const block = await this.getBlockFromNetwork(height);
                    if (block) {
                        await this.addBlock(block);
                    }
                }
            }
            
            async getBlockFromNetwork(height) {
                // Query peers for the block at this height
                for (const peer of this.peers) {
                    try {
                        const response = await this.queryPeer(peer, 'getBlock', { height });
                        if (response) {
                            return response;
                        }
                    } catch (error) {
                        console.error('Error getting block from peer:', peer.id, error);
                    }
                }
                return null;
            }
            
            async broadcastPendingTransactions() {
                const pendingTxs = await this.getPendingTransactions();
                for (const tx of pendingTxs) {
                    await this.broadcastTransaction(tx);
                }
            }
            
            async broadcastTransaction(transaction) {
                for (const peer of this.peers) {
                    try {
                        await this.queryPeer(peer, 'sendTransaction', transaction);
                    } catch (error) {
                        console.error('Error broadcasting transaction to peer:', peer.id, error);
                    }
                }
            }
            
            async addBlock(block) {
                // Validate block
                if (!this.validateBlock(block)) {
                    throw new Error('Invalid block');
                }
                
                // Add to database
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readwrite');
                    const store = transaction.objectStore('blocks');
                    const request = store.put(block);
                    
                    request.onsuccess = async () => {
                        // Process transactions in block
                        for (const tx of block.transactions) {
                            await this.processTransaction(tx, block.height);
                        }
                        resolve();
                    };
                    
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            validateBlock(block) {
                // Basic validation
                if (!block.height && block.height !== 0) return false;
                if (!block.timestamp) return false;
                if (!block.hash) return false;
                if (!block.previousHash && block.height !== 0) return false;
                
                // Validate hash
                const calculatedHash = this.calculateBlockHash(
                    block.height,
                    block.previousHash,
                    block.transactions,
                    block.timestamp
                );
                
                if (calculatedHash !== block.hash) return false;
                
                // Validate transactions
                for (const tx of block.transactions) {
                    if (!this.validateTransaction(tx)) return false;
                }
                
                return true;
            }
            
            calculateBlockHash(height, previousHash, transactions, timestamp) {
                const data = `${height}${previousHash}${JSON.stringify(transactions)}${timestamp}`;
                return this.hash(data);
            }
            
            hash(data) {
                // Simple hash function for demo purposes
                // In a real implementation, use SHA-256 or similar
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash.toString(16);
            }
            
            async processTransaction(tx, blockHeight) {
                // Skip if already processed
                const existingTx = await this.getTransaction(tx.hash);
                if (existingTx) return;
                
                // Add to transactions
                await this.addTransaction(tx, blockHeight);
                
                // Update balances
                if (tx.from !== '0') { // Not a coinbase transaction
                    await this.updateBalance(tx.from, -tx.amount - tx.fee);
                }
                await this.updateBalance(tx.to, tx.amount);
                
                // Reward validator
                if (tx.fee > 0) {
                    const validator = await this.getValidator();
                    if (validator) {
                        await this.updateBalance(validator.address, tx.fee);
                    }
                }
                
                // Remove from pending transactions if exists
                await this.removePendingTransaction(tx.hash);
            }
            
            async addTransaction(tx, blockHeight) {
                tx.blockHeight = blockHeight;
                tx.timestamp = tx.timestamp || Date.now();
                
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readwrite');
                    const store = transaction.objectStore('transactions');
                    const request = store.put(tx);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getTransaction(hash) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const request = store.get(hash);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async updateBalance(address, amount) {
                const wallet = await this.getWallet(address);
                if (!wallet) {
                    // Create new wallet
                    await this.createWallet(address, amount);
                } else {
                    // Update existing wallet
                    wallet.balance += amount;
                    await this.saveWallet(wallet);
                }
            }
            
            async getWallet(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readonly');
                    const store = transaction.objectStore('wallets');
                    const request = store.get(address);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async createWallet(address, initialBalance = 0) {
                const wallet = {
                    address,
                    balance: initialBalance,
                    createdAt: Date.now()
                };
                
                return this.saveWallet(wallet);
            }
            
            async saveWallet(wallet) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readwrite');
                    const store = transaction.objectStore('wallets');
                    const request = store.put(wallet);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async removePendingTransaction(hash) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['pendingTransactions'], 'readwrite');
                    const store = transaction.objectStore('pendingTransactions');
                    const request = store.delete(hash);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getPendingTransactions() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['pendingTransactions'], 'readonly');
                    const store = transaction.objectStore('pendingTransactions');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async addPendingTransaction(tx) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['pendingTransactions'], 'readwrite');
                    const store = transaction.objectStore('pendingTransactions');
                    const request = store.put(tx);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getBlockHeight() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.count();
                    
                    request.onsuccess = () => resolve(request.result ? request.result - 1 : 0);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getLatestBlock() {
                const height = await this.getBlockHeight();
                return this.getBlock(height);
            }
            
            async getBlock(height) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.get(height);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getTransactionsForAddress(address, limit = 100) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const txs = request.result || [];
                        const filtered = txs.filter(tx => tx.from === address || tx.to === address)
                                          .sort((a, b) => b.timestamp - a.timestamp)
                                          .slice(0, limit);
                        resolve(filtered);
                    };
                    
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getAllTransactions(limit = 100) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const txs = request.result || [];
                        const sorted = txs.sort((a, b) => b.timestamp - a.timestamp)
                                          .slice(0, limit);
                        resolve(sorted);
                    };
                    
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getSetting(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.get(key);
                    
                    request.onsuccess = () => resolve(request.result ? request.result.value : null);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async setSetting(key, value) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    const request = store.put({ key, value });
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async createTransaction(from, to, amount, memo = '') {
                // Validate inputs
                if (amount <= 0) throw new Error('Amount must be positive');
                
                // Get sender balance
                const balance = await this.getBalance(from);
                if (balance < amount + this.transactionFee) {
                    throw new Error('Insufficient balance');
                }
                
                // Create transaction
                const tx = {
                    from,
                    to,
                    amount,
                    fee: this.transactionFee,
                    memo,
                    timestamp: Date.now(),
                    hash: ''
                };
                
                // Calculate hash
                tx.hash = this.calculateTransactionHash(tx);
                
                return tx;
            }
            
            calculateTransactionHash(tx) {
                const data = `${tx.from}${tx.to}${tx.amount}${tx.fee}${tx.memo}${tx.timestamp}`;
                return this.hash(data);
            }
            
            validateTransaction(tx) {
                // Basic validation
                if (!tx.from && tx.from !== '0') return false;
                if (!tx.to) return false;
                if (!tx.amount || tx.amount <= 0) return false;
                if (!tx.fee || tx.fee < 0) return false;
                if (!tx.hash) return false;
                
                // Validate hash
                const calculatedHash = this.calculateTransactionHash(tx);
                if (calculatedHash !== tx.hash) return false;
                
                return true;
            }
            
            async signTransaction(tx, privateKey) {
                // In a real implementation, this would use proper cryptographic signing
                // For this demo, we'll just add a dummy signature
                tx.signature = 'signed_' + tx.hash;
                return tx;
            }
            
            async submitTransaction(tx) {
                // Add to pending transactions
                await this.addPendingTransaction(tx);
                
                // Broadcast to network
                await this.broadcastTransaction(tx);
                
                return tx.hash;
            }
            
            async getBalance(address) {
                const wallet = await this.getWallet(address);
                return wallet ? wallet.balance : 0;
            }
            
            async getCirculatingSupply() {
                return this.getSetting('circulatingSupply') || 0;
            }
            
            async getRemainingSupply() {
                const circulating = await this.getCirculatingSupply();
                return this.totalSupply - circulating;
            }
            
            async getValidator() {
                // In a real implementation, this would select based on stake amount and randomization
                const stakes = await this.getAllStakes();
                if (stakes.length === 0) return null;
                
                // Sort by stake amount (descending)
                stakes.sort((a, b) => b.amount - a.amount);
                
                // Select the top staker
                return stakes[0];
            }
            
            async getAllStakes() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['stakes'], 'readonly');
                    const store = transaction.objectStore('stakes');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async addStake(address, amount) {
                const stake = await this.getStake(address);
                if (stake) {
                    stake.amount += amount;
                } else {
                    stake = { address, amount };
                }
                
                return this.saveStake(stake);
            }
            
            async removeStake(address, amount) {
                const stake = await this.getStake(address);
                if (!stake) throw new Error('No stake found');
                
                if (stake.amount < amount) throw new Error('Insufficient stake');
                
                stake.amount -= amount;
                if (stake.amount <= 0) {
                    return this.deleteStake(address);
                } else {
                    return this.saveStake(stake);
                }
            }
            
            async getStake(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['stakes'], 'readonly');
                    const store = transaction.objectStore('stakes');
                    const request = store.get(address);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async saveStake(stake) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['stakes'], 'readwrite');
                    const store = transaction.objectStore('stakes');
                    const request = store.put(stake);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async deleteStake(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['stakes'], 'readwrite');
                    const store = transaction.objectStore('stakes');
                    const request = store.delete(address);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async generateAddress() {
                // In a real implementation, this would generate a proper cryptographic key pair
                // For this demo, we'll generate a simple address
                const chars = '0123456789ABCDEF';
                let address = 'KRC';
                for (let i = 0; i < 33; i++) {
                    address += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return address;
            }
            
            // User management
            async createUser(username, password, referralCode = null) {
                // Check if username exists
                const existingUser = await this.getUser(username);
                if (existingUser) throw new Error('Username already exists');
                
                // Generate wallet address
                const address = await this.generateAddress();
                
                // Determine initial balance
                let initialBalance = 0;
                const users = await this.getAllUsers();
                
                if (users.length === 0) {
                    // First user is super admin, gets 50% of supply
                    initialBalance = this.totalSupply * 0.5;
                    this.isSuperAdmin = true;
                } else {
                    // Regular user gets 10% of remaining supply
                    const remainingSupply = await this.getRemainingSupply();
                    initialBalance = remainingSupply * 0.1;
                    
                    // Apply referral reward if applicable
                    if (referralCode) {
                        const referrer = await this.getUserByReferralCode(referralCode);
                        if (referrer) {
                            const referralReward = initialBalance * (this.rewardSettings.referral / 100);
                            await this.updateBalance(referrer.address, referralReward);
                            
                            // Update referrer's referral stats
                            referrer.referrals = (referrer.referrals || 0) + 1;
                            referrer.referralEarnings = (referrer.referralEarnings || 0) + referralReward;
                            await this.saveUser(referrer);
                        }
                    }
                }
                
                // Create wallet
                await this.createWallet(address, initialBalance);
                
                // Update circulating supply
                const circulatingSupply = await this.getCirculatingSupply();
                await this.setSetting('circulatingSupply', circulatingSupply + initialBalance);
                
                // Create user
                const user = {
                    username,
                    password: this.hashPassword(password),
                    address,
                    createdAt: Date.now(),
                    referralCode: this.generateReferralCode(),
                    referrals: 0,
                    referralEarnings: 0,
                    availabilityEarnings: 0,
                    captchaEarnings: 0,
                    adEarnings: 0
                };
                
                await this.saveUser(user);
                return user;
            }
            
            async getUser(username) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['users'], 'readonly');
                    const store = transaction.objectStore('users');
                    const request = store.get(username);
                    
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async getUserByAddress(address) {
                const users = await this.getAllUsers();
                return users.find(u => u.address === address);
            }
            
            async getUserByReferralCode(code) {
                const users = await this.getAllUsers();
                return users.find(u => u.referralCode === code);
            }
            
            async getAllUsers() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['users'], 'readonly');
                    const store = transaction.objectStore('users');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            async saveUser(user) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['users'], 'readwrite');
                    const store = transaction.objectStore('users');
                    const request = store.put(user);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
            
            hashPassword(password) {
                // In a real implementation, use proper password hashing like bcrypt
                return this.hash(password);
            }
            
            generateReferralCode() {
                const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let code = '';
                for (let i = 0; i < 8; i++) {
                    code += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return code;
            }
            
            async authenticate(username, password) {
                const user = await this.getUser(username);
                if (!user) throw new Error('User not found');
                
                if (user.password !== this.hashPassword(password)) {
                    throw new Error('Invalid password');
                }
                
                // Check if this is the first user (super admin)
                const users = await this.getAllUsers();
                if (users.length > 0 && users[0].username === username) {
                    this.isSuperAdmin = true;
                }
                
                this.currentUser = user;
                return user;
            }
            
            async logout() {
                this.currentUser = null;
                this.isSuperAdmin = false;
            }
            
            // Reward functions
            async rewardAvailability(minutes) {
                if (!this.currentUser) return;
                
                const rewardAmount = minutes * this.rewardSettings.availability;
                if (rewardAmount <= 0) return;
                
                // Check remaining supply
                const remainingSupply = await this.getRemainingSupply();
                if (rewardAmount > remainingSupply) {
                    console.log('Not enough remaining supply for availability reward');
                    return;
                }
                
                // Update balance
                await this.updateBalance(this.currentUser.address, rewardAmount);
                
                // Update circulating supply
                const circulatingSupply = await this.getCirculatingSupply();
                await this.setSetting('circulatingSupply', circulatingSupply + rewardAmount);
                
                // Update user stats
                this.currentUser.availabilityEarnings = (this.currentUser.availabilityEarnings || 0) + rewardAmount;
                await this.saveUser(this.currentUser);
                
                // Update UI
                this.updateUI();
            }
            
            async rewardCaptcha() {
                if (!this.currentUser) return;
                
                const rewardAmount = this.rewardSettings.captcha;
                if (rewardAmount <= 0) return;
                
                // Check remaining supply
                const remainingSupply = await this.getRemainingSupply();
                if (rewardAmount > remainingSupply) {
                    console.log('Not enough remaining supply for CAPTCHA reward');
                    return;
                }
                
                // Update balance
                await this.updateBalance(this.currentUser.address, rewardAmount);
                
                // Update circulating supply
                const circulatingSupply = await this.getCirculatingSupply();
                await this.setSetting('circulatingSupply', circulatingSupply + rewardAmount);
                
                // Update user stats
                this.currentUser.captchaEarnings = (this.currentUser.captchaEarnings || 0) + rewardAmount;
                await this.saveUser(this.currentUser);
                
                // Update UI
                this.updateUI();
            }
            
            async rewardAdView() {
                if (!this.currentUser) return;
                
                const rewardAmount = this.rewardSettings.ad;
                if (rewardAmount <= 0) return;
                
                // Check remaining supply
                const remainingSupply = await this.getRemainingSupply();
                if (rewardAmount > remainingSupply) {
                    console.log('Not enough remaining supply for ad reward');
                    return;
                }
                
                // Update balance
                await this.updateBalance(this.currentUser.address, rewardAmount);
                
                // Update circulating supply
                const circulatingSupply = await this.getCirculatingSupply();
                await this.setSetting('circulatingSupply', circulatingSupply + rewardAmount);
                
                // Update user stats
                this.currentUser.adEarnings = (this.currentUser.adEarnings || 0) + rewardAmount;
                await this.saveUser(this.currentUser);
                
                // Update UI
                this.updateUI();
            }
            
            // UI functions
            async checkAuth() {
                const username = Cookies.get('krc_username');
                const password = Cookies.get('krc_password');
                
                if (username && password) {
                    try {
                        await this.authenticate(username, password);
                        document.getElementById('login-modal').style.display = 'none';
                    } catch (error) {
                        console.error('Auto-login failed:', error);
                        this.showLoginModal();
                    }
                } else {
                    this.showLoginModal();
                }
            }
            
            showLoginModal() {
                document.getElementById('login-modal').style.display = 'flex';
                document.getElementById('login-form').style.display = 'block';
                document.getElementById('signup-form').style.display = 'none';
            }
            
            updatePeerStatus() {
                const statusElement = document.getElementById('peer-status');
                const countElement = document.getElementById('peer-count');
                
                if (this.peers.length > 0) {
                    statusElement.classList.add('connected');
                    countElement.textContent = `${this.peers.length} peers connected`;
                } else {
                    statusElement.classList.remove('connected');
                    countElement.textContent = '0 peers connected (offline)';
                }
            }
            
            updateUI() {
                if (!this.currentUser) return;
                
                // Update user info
                document.getElementById('username').textContent = this.currentUser.username;
                document.getElementById('wallet-address').textContent = this.currentUser.address;
                
                // Show/hide admin sections
                const adminElements = document.querySelectorAll('.admin-only');
                adminElements.forEach(el => {
                    el.classList.toggle('hidden', !this.isSuperAdmin);
                });
                
                // Update balance
                this.getBalance(this.currentUser.address).then(balance => {
                    document.getElementById('balance').textContent = `${balance.toFixed(8)} KRC`;
                    
                    // TODO: Fetch exchange rate and calculate fiat value
                    document.getElementById('balance-fiat').textContent = `$${(balance * 0.10).toFixed(2)}`;
                });
                
                // Update transactions
                this.getTransactionsForAddress(this.currentUser.address, 5).then(txs => {
                    const element = document.getElementById('recent-transactions');
                    if (txs.length === 0) {
                        element.innerHTML = '<p>No recent transactions</p>';
                        return;
                    }
                    
                    let html = '<table><thead><tr><th>Type</th><th>Amount</th><th>Address</th><th>Date</th></tr></thead><tbody>';
                    
                    txs.forEach(tx => {
                        const type = tx.from === this.currentUser.address ? 'Sent' : 'Received';
                        const amount = type === 'Sent' ? -tx.amount : tx.amount;
                        const address = type === 'Sent' ? tx.to : tx.from;
                        const date = new Date(tx.timestamp).toLocaleString();
                        
                        html += `<tr>
                            <td>${type}</td>
                            <td>${amount.toFixed(8)} KRC</td>
                            <td>${address.substring(0, 6)}...${address.substring(address.length - 4)}</td>
                            <td>${date}</td>
                        </tr>`;
                    });
                    
                    html += '</tbody></table>';
                    element.innerHTML = html;
                });
                
                // Update network info
                this.getBlockHeight().then(height => {
                    document.getElementById('block-height').textContent = height;
                });
                
                this.getCirculatingSupply().then(supply => {
                    document.getElementById('circulating-supply').textContent = supply.toFixed(8);
                    document.getElementById('total-supply').textContent = this.totalSupply.toFixed(8);
                });
                
                // Update receive address
                document.getElementById('receive-address').textContent = this.currentUser.address;
                
                // Update referral info
                document.getElementById('referral-link').value = 
                    `${window.location.origin}${window.location.pathname}?ref=${this.currentUser.referralCode}`;
                document.getElementById('total-referrals').textContent = this.currentUser.referrals || 0;
                document.getElementById('referral-earnings').textContent = 
                    `${(this.currentUser.referralEarnings || 0).toFixed(8)} KRC`;
                
                // Update availability info
                document.getElementById('availability-rate').textContent = this.rewardSettings.availability.toFixed(8);
                document.getElementById('availability-earnings').textContent = 
                    `${(this.currentUser.availabilityEarnings || 0).toFixed(8)} KRC`;
                
                // Update CAPTCHA info
                document.getElementById('captcha-reward').textContent = this.rewardSettings.captcha.toFixed(8);
                document.getElementById('captcha-earnings').textContent = 
                    `${(this.currentUser.captchaEarnings || 0).toFixed(8)} KRC`;
                this.generateCaptcha();
                
                // Update ad info
                document.getElementById('ad-reward').textContent = this.rewardSettings.ad.toFixed(8);
                document.getElementById('ad-earnings').textContent = 
                    `${(this.currentUser.adEarnings || 0).toFixed(8)} KRC`;
                
                // Update node info
                document.getElementById('node-id').textContent = this.nodeId || 'Not available';
                document.getElementById('node-peers').textContent = this.peers.length;
                
                // Update admin dashboard
                if (this.isSuperAdmin) {
                    this.getBlockHeight().then(height => {
                        document.getElementById('admin-total-supply').textContent = 
                            this.totalSupply.toLocaleString();
                        document.getElementById('admin-circulating-supply').textContent = 
                            (await this.getCirculatingSupply()).toLocaleString();
                    });
                    
                    this.getAllUsers().then(users => {
                        document.getElementById('admin-active-users').textContent = users.length;
                    });
                }
            }
            
            generateCaptcha() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789';
                let text = '';
                for (let i = 0; i < 6; i++) {
                    text += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                this.captchaText = text;
                document.getElementById('captcha-display').textContent = text;
            }
            
            startAvailabilityRewards() {
                if (this.availabilityInterval) {
                    clearInterval(this.availabilityInterval);
                }
                
                let minutesActive = 0;
                this.availabilityInterval = setInterval(() => {
                    minutesActive++;
                    this.rewardAvailability(1);
                    
                    // Update UI
                    const statusElement = document.getElementById('availability-status-text');
                    const timeElement = document.getElementById('time-online');
                    
                    if (statusElement) statusElement.textContent = 'Active';
                    if (timeElement) timeElement.textContent = `${minutesActive} minutes`;
                }, 60000); // Every minute
            }
            
            showToast(message, type = 'info') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = 'toast';
                toast.classList.add(type);
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
        }

        // Initialize Kiira Coin
        const krc = new KiiraCoin();

        // Event listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Navigation
            document.querySelectorAll('.nav-link, .sidebar-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const section = link.getAttribute('data-section');
                    showSection(section);
                });
            });
            
            // Tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabContainer = tab.closest('.tab-container');
                    const tabName = tab.getAttribute('data-tab');
                    
                    // Update active tab
                    tabContainer.querySelectorAll('.tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    tab.classList.add('active');
                    
                    // Update active content
                    tabContainer.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                        if (content.getAttribute('data-tab-content') === tabName) {
                            content.classList.add('active');
                        }
                    });
                });
            });
            
            // Login/Signup forms
            document.getElementById('show-signup').addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('login-form').style.display = 'none';
                document.getElementById('signup-form').style.display = 'block';
            });
            
            document.getElementById('show-login').addEventListener('click', (e) => {
                e.preventDefault();
                document.getElementById('signup-form').style.display = 'none';
                document.getElementById('login-form').style.display = 'block';
            });
            
            document.getElementById('login-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('login-username').value;
                const password = document.getElementById('login-password').value;
                
                try {
                    await krc.authenticate(username, password);
                    document.getElementById('login-modal').style.display = 'none';
                    
                    // Save credentials in cookies (not secure, just for demo)
                    Cookies.set('krc_username', username, { expires: 30 });
                    Cookies.set('krc_password', password, { expires: 30 });
                    
                    krc.updateUI();
                    krc.showToast('Login successful', 'success');
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            document.getElementById('signup-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('signup-username').value;
                const password = document.getElementById('signup-password').value;
                const confirmPassword = document.getElementById('signup-confirm-password').value;
                const referralCode = document.getElementById('signup-referral').value;
                
                if (password !== confirmPassword) {
                    krc.showToast('Passwords do not match', 'error');
                    return;
                }
                
                try {
                    await krc.createUser(username, password, referralCode);
                    document.getElementById('signup-form').reset();
                    document.getElementById('login-form').style.display = 'block';
                    document.getElementById('signup-form').style.display = 'none';
                    
                    krc.showToast('Account created successfully. Please login.', 'success');
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            document.getElementById('logout-btn').addEventListener('click', async (e) => {
                e.preventDefault();
                await krc.logout();
                Cookies.remove('krc_username');
                Cookies.remove('krc_password');
                krc.showLoginModal();
                krc.showToast('Logged out successfully', 'success');
            });
            
            // Send form
            document.getElementById('send-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const toAddress = document.getElementById('recipient-address').value;
                const amount = parseFloat(document.getElementById('send-amount').value);
                const memo = document.getElementById('send-memo').value;
                
                if (!toAddress.startsWith('KRC')) {
                    krc.showToast('Invalid recipient address', 'error');
                    return;
                }
                
                if (isNaN(amount) {
                    krc.showToast('Invalid amount', 'error');
                    return;
                }
                
                try {
                    const tx = await krc.createTransaction(krc.currentUser.address, toAddress, amount, memo);
                    // In a real implementation, we would sign the transaction with the user's private key
                    const signedTx = await krc.signTransaction(tx, 'private_key_placeholder');
                    const txHash = await krc.submitTransaction(signedTx);
                    
                    document.getElementById('send-form').reset();
                    krc.showToast(`Transaction submitted (${txHash.substring(0, 8)}...)`, 'success');
                    krc.updateUI();
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            // Copy address
            document.getElementById('copy-address-btn').addEventListener('click', () => {
                navigator.clipboard.writeText(krc.currentUser.address);
                krc.showToast('Address copied to clipboard', 'success');
            });
            
            // Copy referral link
            document.getElementById('copy-referral-link').addEventListener('click', () => {
                const referralLink = document.getElementById('referral-link').value;
                navigator.clipboard.writeText(referralLink);
                krc.showToast('Referral link copied to clipboard', 'success');
            });
            
            // Toggle availability
            document.getElementById('toggle-availability-btn').addEventListener('click', () => {
                const btn = document.getElementById('toggle-availability-btn');
                if (btn.textContent === 'Start Earning') {
                    btn.textContent = 'Stop Earning';
                    krc.startAvailabilityRewards();
                    krc.showToast('Availability rewards started', 'success');
                } else {
                    btn.textContent = 'Start Earning';
                    clearInterval(krc.availabilityInterval);
                    krc.availabilityInterval = null;
                    document.getElementById('availability-status-text').textContent = 'Inactive';
                    krc.showToast('Availability rewards stopped', 'warning');
                }
            });
            
            // CAPTCHA
            document.getElementById('verify-captcha-btn').addEventListener('click', () => {
                const input = document.getElementById('captcha-input').value;
                if (input === krc.captchaText) {
                    krc.rewardCaptcha();
                    document.getElementById('captcha-input').value = '';
                    krc.generateCaptcha();
                    krc.showToast('CAPTCHA solved! Reward added to your balance.', 'success');
                } else {
                    krc.showToast('Incorrect CAPTCHA', 'error');
                }
            });
            
            document.getElementById('new-captcha-btn').addEventListener('click', () => {
                krc.generateCaptcha();
            });
            
            // Ad view
            document.getElementById('view-ad-btn').addEventListener('click', () => {
                // Simulate ad view
                setTimeout(() => {
                    krc.rewardAdView();
                    krc.showToast('Ad viewed! Reward added to your balance.', 'success');
                }, 3000);
            });
            
            // Stake form
            document.getElementById('stake-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const amount = parseFloat(document.getElementById('stake-amount').value);
                
                if (isNaN(amount) {
                    krc.showToast('Invalid amount', 'error');
                    return;
                }
                
                try {
                    await krc.addStake(krc.currentUser.address, amount);
                    krc.showToast(`${amount} KRC staked successfully`, 'success');
                    krc.updateUI();
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            document.getElementById('unstake-btn').addEventListener('click', async (e) => {
                e.preventDefault();
                const amount = parseFloat(document.getElementById('stake-amount').value);
                
                if (isNaN(amount)) {
                    krc.showToast('Invalid amount', 'error');
                    return;
                }
                
                try {
                    await krc.removeStake(krc.currentUser.address, amount);
                    krc.showToast(`${amount} KRC unstaked successfully`, 'success');
                    krc.updateUI();
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            // Quick action buttons
            document.getElementById('send-btn').addEventListener('click', () => {
                showSection('send');
            });
            
            document.getElementById('receive-btn').addEventListener('click', () => {
                showSection('receive');
            });
            
            document.getElementById('earn-btn').addEventListener('click', () => {
                showSection('earn');
            });
            
            // Admin forms
            document.getElementById('token-settings-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = document.getElementById('token-name').value;
                const symbol = document.getElementById('token-symbol').value;
                const decimals = parseInt(document.getElementById('token-decimals').value);
                const description = document.getElementById('token-description').value;
                
                // Handle icon upload
                const iconInput = document.getElementById('token-icon');
                if (iconInput.files.length > 0) {
                    const file = iconInput.files[0];
                    const reader = new FileReader();
                    
                    reader.onload = async (e) => {
                        // In a real implementation, we would upload to IPFS
                        document.getElementById('coin-icon').src = e.target.result;
                        krc.showToast('Token settings saved', 'success');
                    };
                    
                    reader.readAsDataURL(file);
                } else {
                    krc.showToast('Token settings saved', 'success');
                }
            });
            
            document.getElementById('reward-settings-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const referral = parseFloat(document.getElementById('referral-reward').value);
                const availability = parseFloat(document.getElementById('availability-reward').value);
                const captcha = parseFloat(document.getElementById('captcha-reward').value);
                const ad = parseFloat(document.getElementById('ad-reward').value);
                const staking = parseFloat(document.getElementById('staking-reward').value);
                const minStake = parseFloat(document.getElementById('min-stake-reward').value);
                
                krc.rewardSettings = {
                    referral,
                    availability,
                    captcha,
                    ad,
                    staking
                };
                
                krc.minStake = minStake;
                
                await krc.setSetting('rewardSettings', krc.rewardSettings);
                await krc.setSetting('minStake', krc.minStake);
                
                krc.showToast('Reward settings saved', 'success');
                krc.updateUI();
            });
            
            document.getElementById('token-distribution-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const address = document.getElementById('distribution-address').value;
                const amount = parseFloat(document.getElementById('distribution-amount').value);
                const memo = document.getElementById('distribution-memo').value;
                
                if (!address.startsWith('KRC')) {
                    krc.showToast('Invalid recipient address', 'error');
                    return;
                }
                
                if (isNaN(amount)) {
                    krc.showToast('Invalid amount', 'error');
                    return;
                }
                
                try {
                    // Check remaining supply
                    const remainingSupply = await krc.getRemainingSupply();
                    if (amount > remainingSupply) {
                        krc.showToast('Not enough remaining supply', 'error');
                        return;
                    }
                    
                    // Update balance
                    await krc.updateBalance(address, amount);
                    
                    // Update circulating supply
                    const circulatingSupply = await krc.getCirculatingSupply();
                    await krc.setSetting('circulatingSupply', circulatingSupply + amount);
                    
                    // Create transaction record
                    const tx = {
                        from: '0',
                        to: address,
                        amount,
                        fee: 0,
                        memo: memo || 'Token distribution',
                        timestamp: Date.now(),
                        hash: krc.calculateTransactionHash({
                            from: '0',
                            to: address,
                            amount,
                            fee: 0,
                            memo: memo || 'Token distribution',
                            timestamp: Date.now()
                        })
                    };
                    
                    await krc.addTransaction(tx, await krc.getBlockHeight());
                    
                    document.getElementById('token-distribution-form').reset();
                    krc.showToast(`${amount} KRC distributed to ${address}`, 'success');
                    krc.updateUI();
                } catch (error) {
                    krc.showToast(error.message, 'error');
                }
            });
            
            // Exchange integration
            document.getElementById('submit-coingecko-btn').addEventListener('click', () => {
                krc.showToast('Submission to CoinGecko would be processed here', 'info');
            });
            
            document.getElementById('submit-coinmarketcap-btn').addEventListener('click', () => {
                krc.showToast('Submission to CoinMarketCap would be processed here', 'info');
            });
            
            document.getElementById('generate-listing-package').addEventListener('click', () => {
                krc.showToast('Listing package generated', 'success');
            });
            
            // Network settings
            document.getElementById('network-settings-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const blockTime = parseInt(document.getElementById('block-time').value);
                const transactionFee = parseFloat(document.getElementById('transaction-fee-setting').value);
                const bootstrapNodes = document.getElementById('bootstrap-nodes').value.split(',').map(n => n.trim());
                const maxPeers = parseInt(document.getElementById('max-peers').value);
                const difficultyAdjustment = parseInt(document.getElementById('difficulty-adjustment').value);
                
                krc.blockTime = blockTime;
                krc.transactionFee = transactionFee;
                
                await krc.setSetting('blockTime', blockTime);
                await krc.setSetting('transactionFee', transactionFee);
                await krc.setSetting('bootstrapNodes', bootstrapNodes);
                await krc.setSetting('maxPeers', maxPeers);
                await krc.setSetting('difficultyAdjustment', difficultyAdjustment);
                
                krc.showToast('Network settings saved', 'success');
            });
            
            // Network maintenance
            document.getElementById('export-chain-btn').addEventListener('click', () => {
                krc.showToast('Blockchain export would be processed here', 'info');
            });
            
            document.getElementById('import-chain-btn').addEventListener('click', () => {
                krc.showToast('Blockchain import would be processed here', 'info');
            });
            
            document.getElementById('reset-chain-btn').addEventListener('click', () => {
                if (confirm('Are you sure you want to reset the blockchain? This cannot be undone.')) {
                    krc.showToast('Blockchain reset would be processed here', 'warning');
                }
            });
            
            // Support form
            document.getElementById('support-form').addEventListener('submit', (e) => {
                e.preventDefault();
                document.getElementById('support-form').reset();
                krc.showToast('Support request submitted', 'success');
            });
            
            // Developer resources
            document.getElementById('download-api-docs').addEventListener('click', () => {
                krc.showToast('API documentation download would start here', 'info');
            });
            
            document.getElementById('copy-integration-code').addEventListener('click', () => {
                const code = document.querySelector('#developer pre').textContent;
                navigator.clipboard.writeText(code);
                krc.showToast('Integration code copied to clipboard', 'success');
            });
            
            // Copy Docker command
            document.getElementById('copy-docker-command').addEventListener('click', () => {
                const code = document.querySelector('#docker-setup pre').textContent;
                navigator.clipboard.writeText(code);
                krc.showToast('Docker command copied to clipboard', 'success');
            });
            
            // Start/stop node
            document.getElementById('start-node-btn').addEventListener('click', () => {
                document.getElementById('node-status').textContent = 'Running';
                krc.showToast('Node started', 'success');
            });
            
            document.getElementById('stop-node-btn').addEventListener('click', () => {
                document.getElementById('node-status').textContent = 'Stopped';
                krc.showToast('Node stopped', 'warning');
            });
        });

        function showSection(section) {
            // Hide all sections
            document.querySelectorAll('.section-content').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show selected section
            document.getElementById(`${section}-section`).classList.add('active');
            
            // Update active nav link
            document.querySelectorAll('.nav-link, .sidebar-link').forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('data-section') === section) {
                    link.classList.add('active');
                }
            });
        }
    </script>
</body>
</html>
