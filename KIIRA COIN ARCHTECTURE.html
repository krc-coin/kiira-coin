<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiira Coin Blockchain</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-ipfs@0.65.0/dist/index.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4fc3f7;
            --background: #f5f7fa;
            --text: #333;
            --card: #fff;
            --error: #e53935;
            --success: #43a047;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        body {
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            background-color: var(--primary);
            color: white;
            padding: 20px 0;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        header .container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .logo img {
            height: 40px;
            width: 40px;
            border-radius: 50%;
        }
        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        nav a:hover {
            background-color: rgba(255,255,255,0.2);
        }
        .dashboard {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
        }
        .sidebar {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .sidebar h3 {
            margin-bottom: 15px;
            color: var(--secondary);
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .sidebar ul {
            list-style: none;
        }
        .sidebar li {
            margin-bottom: 10px;
        }
        .sidebar a {
            color: var(--text);
            text-decoration: none;
            display: block;
            padding: 8px 10px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .sidebar a:hover, .sidebar a.active {
            background-color: var(--accent);
            color: white;
        }
        .main-content {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .card {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .card h3 {
            margin-bottom: 15px;
            color: var(--secondary);
        }
        .balance {
            font-size: 2rem;
            font-weight: bold;
            margin: 20px 0;
            color: var(--primary);
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: var(--secondary);
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #6c757d;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .btn-accent {
            background-color: var(--accent);
        }
        .btn-accent:hover {
            background-color: #29b6f6;
        }
        .alert {
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
        }
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            flex-direction: column;
            gap: 20px;
        }
        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden {
            display: none !important;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        tr:hover {
            background-color: #f5f5f5;
        }
        .badge {
            display: inline-block;
            padding: 3px 7px;
            font-size: 12px;
            font-weight: 600;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 10px;
        }
        .badge-success {
            background-color: var(--success);
            color: white;
        }
        .badge-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .badge-info {
            background-color: #17a2b8;
            color: white;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }
        .tab.active {
            border-bottom-color: var(--primary);
            font-weight: 600;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .peer-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .peer-status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #28a745;
        }
        .peer-status-indicator.offline {
            background-color: #dc3545;
        }
        .admin-only {
            border-left: 3px solid var(--accent);
            padding-left: 10px;
            margin: 10px 0;
        }
        .referral-link {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            word-break: break-all;
            margin: 10px 0;
        }
        .captcha-container {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            margin: 20px 0;
        }
        .captcha-text {
            font-size: 24px;
            letter-spacing: 5px;
            margin: 15px 0;
            color: var(--secondary);
            font-weight: bold;
        }
        .online-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: #28a745;
            margin-right: 5px;
        }
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #666;
            font-size: 14px;
        }
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            header .container {
                flex-direction: column;
                gap: 15px;
            }
            nav ul {
                flex-wrap: wrap;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen" class="loading">
        <div class="spinner"></div>
        <div id="loading-text">Initializing Kiira Coin Blockchain...</div>
        <div id="loading-details"></div>
    </div>

    <div id="app" class="hidden">
        <header>
            <div class="container">
                <div class="logo">
                    <img id="coin-icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZmlsbD0id2hpdGUiIGQ9Ik0xMiwyQTEwLDEwIDAgMCwxIDIyLDEyQTEwLDEwIDAgMCwxIDEyLDIyQTEwLDEwIDAgMCwxIDIsMTJBMTAsMTAgMCAwLDEgMTIsMk0xMiw0QTgsOCAwIDAsMCA0LDEyQTgsOCAwIDAsMCAxMiwyMEE4LDggMCAwLDAgMjAsMTJBOCw4IDAgMCwwIDEyLDRNNywxMEwxMiwxNUwxNywxMEg3WiIvPjwvc3ZnPg==" alt="Kiira Coin">
                    <h1>Kiira Coin (KRC)</h1>
                </div>
                <nav>
                    <ul>
                        <li><a href="#" class="nav-link" data-section="dashboard">Dashboard</a></li>
                        <li><a href="#" class="nav-link" data-section="wallet">Wallet</a></li>
                        <li><a href="#" class="nav-link" data-section="transactions">Transactions</a></li>
                        <li><a href="#" class="nav-link" data-section="network">Network</a></li>
                        <li id="admin-nav-item" class="hidden"><a href="#" class="nav-link" data-section="admin">Admin</a></li>
                    </ul>
                </nav>
            </div>
        </header>

        <div class="container">
            <div id="dashboard-section" class="tab-content active">
                <div class="card">
                    <h2>Welcome to Kiira Coin</h2>
                    <p>Kiira Coin (KRC) is a lightweight blockchain with Proof of Stake consensus, designed for low resource usage and easy integration.</p>
                </div>

                <div class="dashboard">
                    <div class="sidebar">
                        <div class="card">
                            <h3>Account</h3>
                            <div class="balance" id="account-balance">0 KRC</div>
                            <p>Address: <span id="account-address" class="referral-link">Loading...</span></p>
                            <p id="online-status"><span class="online-status"></span> <span id="online-status-text">Online</span></p>
                            <button id="copy-address" class="btn-secondary">Copy Address</button>
                        </div>

                        <div class="card">
                            <h3>Quick Actions</h3>
                            <ul>
                                <li><a href="#" id="send-funds-link">Send KRC</a></li>
                                <li><a href="#" id="receive-funds-link">Receive KRC</a></li>
                                <li><a href="#" id="stake-funds-link">Stake KRC</a></li>
                                <li><a href="#" id="earn-krc-link">Earn KRC</a></li>
                            </ul>
                        </div>

                        <div class="card">
                            <h3>Network Info</h3>
                            <p>Peers: <span id="peer-count">0</span></p>
                            <p>Block Height: <span id="block-height">0</span></p>
                            <p>Total Supply: <span id="total-supply">10,000,000</span> KRC</p>
                            <p>Circulating: <span id="circulating-supply">0</span> KRC</p>
                        </div>
                    </div>

                    <div class="main-content">
                        <div class="card">
                            <h3>Recent Transactions</h3>
                            <div id="recent-transactions">
                                <p>Loading transactions...</p>
                            </div>
                        </div>

                        <div class="card">
                            <h3>Earn KRC</h3>
                            <div class="tabs">
                                <div class="tab active" data-tab="referral">Referrals</div>
                                <div class="tab" data-tab="captcha">CAPTCHA</div>
                                <div class="tab" data-tab="online">Online Time</div>
                            </div>

                            <div class="tab-content active" data-tab-content="referral">
                                <p>Invite friends to join Kiira Coin and earn 10% of their initial balance!</p>
                                <div class="form-group">
                                    <label>Your Referral Link:</label>
                                    <div class="referral-link" id="referral-link">Loading...</div>
                                    <button id="copy-referral" class="btn-secondary">Copy Link</button>
                                </div>
                                <div id="referral-stats">
                                    <p>Total Referrals: <span id="referral-count">0</span></p>
                                    <p>Earned from Referrals: <span id="referral-earnings">0</span> KRC</p>
                                </div>
                            </div>

                            <div class="tab-content" data-tab-content="captcha">
                                <div class="captcha-container">
                                    <p>Solve CAPTCHAs to earn KRC</p>
                                    <div class="captcha-text" id="captcha-text">Loading...</div>
                                    <div class="form-group">
                                        <input type="text" id="captcha-input" placeholder="Enter the text above">
                                    </div>
                                    <button id="verify-captcha" class="btn-accent">Verify & Earn</button>
                                    <p id="captcha-result"></p>
                                </div>
                                <div id="captcha-stats">
                                    <p>CAPTCHAs Solved: <span id="captcha-count">0</span></p>
                                    <p>Earned from CAPTCHAs: <span id="captcha-earnings">0</span> KRC</p>
                                </div>
                            </div>

                            <div class="tab-content" data-tab-content="online">
                                <p>Stay online to earn KRC based on your online time</p>
                                <div id="online-time-stats">
                                    <p>Online Time Today: <span id="online-time-today">0</span> minutes</p>
                                    <p>Estimated Earnings Today: <span id="online-earnings-today">0</span> KRC</p>
                                    <p>Total Earned from Online Time: <span id="online-earnings-total">0</span> KRC</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="wallet-section" class="tab-content">
                <div class="card">
                    <h2>Wallet</h2>
                    <div class="balance" id="wallet-balance">0 KRC</div>
                    <p>Address: <span id="wallet-address" class="referral-link">Loading...</span></p>
                    <p>Public Key: <span id="wallet-public-key" class="referral-link">Loading...</span></p>
                    <button id="export-wallet" class="btn-secondary">Export Wallet (Secure)</button>
                    <div id="export-warning" class="alert alert-error hidden">
                        <p>Never share your private key with anyone! Store it securely.</p>
                    </div>
                </div>

                <div class="card">
                    <h3>Send KRC</h3>
                    <div class="form-group">
                        <label>Recipient Address (KRC...)</label>
                        <input type="text" id="send-to" placeholder="KRC...">
                    </div>
                    <div class="form-group">
                        <label>Amount (KRC)</label>
                        <input type="number" id="send-amount" min="0" step="0.00000001">
                    </div>
                    <div class="form-group">
                        <label>Memo (Optional)</label>
                        <input type="text" id="send-memo" placeholder="What's this for?">
                    </div>
                    <button id="send-button">Send</button>
                    <div id="send-result"></div>
                </div>

                <div class="card">
                    <h3>Receive KRC</h3>
                    <div class="form-group">
                        <label>Your Address</label>
                        <div class="referral-link" id="receive-address">Loading...</div>
                        <button id="copy-receive-address" class="btn-secondary">Copy Address</button>
                    </div>
                    <div class="form-group">
                        <label>QR Code</label>
                        <div id="qr-code" style="width: 200px; height: 200px; margin: 0 auto; background-color: white; padding: 10px;"></div>
                    </div>
                </div>
            </div>

            <div id="transactions-section" class="tab-content">
                <div class="card">
                    <h2>Transaction History</h2>
                    <div class="form-group">
                        <input type="text" id="transaction-search" placeholder="Search transactions...">
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>Amount</th>
                                <th>From/To</th>
                                <th>Date</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="transaction-list">
                            <tr>
                                <td colspan="6">Loading transactions...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="network-section" class="tab-content">
                <div class="card">
                    <h2>Network Nodes</h2>
                    <p>Connected to <span id="connected-peers-count">0</span> peers</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Peer ID</th>
                                <th>Address</th>
                                <th>Status</th>
                                <th>Last Seen</th>
                                <th>Stake</th>
                            </tr>
                        </thead>
                        <tbody id="peer-list">
                            <tr>
                                <td colspan="5">Loading peers...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card">
                    <h2>Blockchain Info</h2>
                    <p>Current Block Height: <span id="current-block-height">0</span></p>
                    <p>Total Transactions: <span id="total-transactions">0</span></p>
                    <p>Consensus: Proof of Stake</p>
                    <p>Network Hashrate: <span id="network-hashrate">0</span></p>
                    <button id="sync-blocks" class="btn-secondary">Sync Latest Blocks</button>
                </div>

                <div class="card">
                    <h2>Validator Node</h2>
                    <div id="validator-status">
                        <p>Staked Amount: <span id="staked-amount">0</span> KRC</p>
                        <p>Validator Status: <span id="validator-status-text">Not a validator</span></p>
                        <p>Last Validated Block: <span id="last-validated-block">None</span></p>
                        <p>Validation Rewards: <span id="validation-rewards">0</span> KRC</p>
                    </div>
                    <div class="form-group">
                        <label>Amount to Stake (KRC)</label>
                        <input type="number" id="stake-amount" min="0" step="0.00000001">
                    </div>
                    <button id="stake-button">Stake KRC</button>
                    <button id="unstake-button" class="btn-secondary">Unstake KRC</button>
                    <div id="stake-result"></div>
                </div>
            </div>

            <div id="admin-section" class="tab-content">
                <div class="card">
                    <h2>Admin Dashboard</h2>
                    <div id="admin-stats">
                        <p>Total Users: <span id="total-users">0</span></p>
                        <p>Total Transactions: <span id="admin-total-tx">0</span></p>
                        <p>Remaining Supply: <span id="remaining-supply">0</span> KRC</p>
                        <p>Your Admin Balance: <span id="admin-balance">0</span> KRC</p>
                    </div>
                </div>

                <div class="card">
                    <h3>Coin Settings</h3>
                    <div class="form-group">
                        <label>Coin Name</label>
                        <input type="text" id="coin-name" value="Kiira Coin">
                    </div>
                    <div class="form-group">
                        <label>Coin Symbol</label>
                        <input type="text" id="coin-symbol" value="KRC">
                    </div>
                    <div class="form-group">
                        <label>Coin Icon (Base64 or URL)</label>
                        <input type="text" id="coin-icon-input">
                        <button id="update-coin-icon" class="btn-secondary">Update Icon</button>
                    </div>
                    <div class="form-group">
                        <label>Total Supply</label>
                        <input type="number" id="total-supply-input" value="10000000" disabled>
                    </div>
                    <button id="save-coin-settings">Save Settings</button>
                </div>

                <div class="card">
                    <h3>Reward Settings</h3>
                    <div class="form-group">
                        <label>Referral Reward (%)</label>
                        <input type="number" id="referral-reward" min="0" max="100" step="0.1" value="10">
                    </div>
                    <div class="form-group">
                        <label>CAPTCHA Reward (KRC per solve)</label>
                        <input type="number" id="captcha-reward" min="0" step="0.00000001" value="0.1">
                    </div>
                    <div class="form-group">
                        <label>Online Reward (KRC per minute)</label>
                        <input type="number" id="online-reward" min="0" step="0.00000001" value="0.001">
                    </div>
                    <div class="form-group">
                        <label>Validator Reward (KRC per block)</label>
                        <input type="number" id="validator-reward" min="0" step="0.00000001" value="0.5">
                    </div>
                    <button id="save-reward-settings">Save Reward Settings</button>
                </div>

                <div class="card">
                    <h3>Exchange Integration</h3>
                    <div class="form-group">
                        <label>CoinGecko API Key</label>
                        <input type="password" id="coingecko-api">
                    </div>
                    <div class="form-group">
                        <label>CoinMarketCap API Key</label>
                        <input type="password" id="coinmarketcap-api">
                    </div>
                    <div class="form-group">
                        <label>CryptoCompare API Key</label>
                        <input type="password" id="cryptocompare-api">
                    </div>
                    <div class="form-group">
                        <label>Infura Project ID</label>
                        <input type="password" id="infura-api">
                    </div>
                    <div class="form-group">
                        <label>Exchange Rate (KRC/USD)</label>
                        <input type="number" id="exchange-rate" min="0" step="0.000001" value="0.01">
                    </div>
                    <button id="save-exchange-settings">Save Exchange Settings</button>
                    <button id="submit-to-exchanges" class="btn-accent">Submit to Exchanges</button>
                </div>

                <div class="card">
                    <h3>Developer Integration</h3>
                    <div class="form-group">
                        <label>HTML/JS Code for Websites</label>
                        <textarea id="integration-code" readonly rows="10"></textarea>
                        <button id="copy-integration-code" class="btn-secondary">Copy Code</button>
                    </div>
                    <div class="form-group">
                        <label>API Documentation</label>
                        <textarea id="api-docs" readonly rows="10"></textarea>
                        <button id="copy-api-docs" class="btn-secondary">Copy Docs</button>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Kiira Coin (KRC) - A lightweight blockchain with Proof of Stake consensus</p>
            <p>Total Supply: 10,000,000 KRC | Current Version: 1.0.0</p>
        </footer>
    </div>

    <script>
        // Kiira Coin Blockchain Implementation
        class KiiraCoinBlockchain {
            constructor() {
                this.db = null;
                this.peer = null;
                this.ipfs = null;
                this.ec = new elliptic.ec('secp256k1');
                this.keyPair = null;
                this.walletAddress = null;
                this.blocks = [];
                this.pendingTransactions = [];
                this.peers = [];
                this.isSuperAdmin = false;
                this.chainId = 'krc-mainnet-1';
                this.difficulty = 2;
                this.stakeReward = 0.5;
                this.referralReward = 0.1; // 10%
                this.captchaReward = 0.1;
                this.onlineReward = 0.001; // per minute
                this.totalSupply = 10000000; // 10 million KRC
                this.initialUserReward = 0.1; // 10% of remaining supply
                this.superAdminInitialReward = 0.5; // 50% of total supply
                this.blockTime = 30; // seconds
                this.lastBlockTime = Date.now();
                this.validatorNodes = {};
                this.onlineTimer = null;
                this.onlineMinutes = 0;
                this.captchaSolutions = {};
                this.referrals = {};
                this.peerId = null;
                this.bootstrapped = false;
                this.genesisBlock = null;
                this.currentBlock = null;
                this.connectedPeers = [];
                this.bootstrapNodes = [
                    '/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ',
                    '/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN'
                ];
                
                this.init();
            }
            
            async init() {
                try {
                    // Initialize IndexedDB
                    await this.initDB();
                    
                    // Initialize IPFS
                    await this.initIPFS();
                    
                    // Initialize PeerJS
                    await this.initPeerJS();
                    
                    // Load or create wallet
                    await this.loadOrCreateWallet();
                    
                    // Load blockchain data
                    await this.loadBlockchain();
                    
                    // Initialize network
                    await this.initNetwork();
                    
                    // Start blockchain operations
                    this.startBlockchain();
                    
                    // Update UI
                    this.updateUI();
                    
                    // Hide loading screen and show app
                    document.getElementById('loading-screen').classList.add('hidden');
                    document.getElementById('app').classList.remove('hidden');
                    
                    // Start online time tracking
                    this.startOnlineTimeTracking();
                    
                    // Generate CAPTCHA
                    this.generateCaptcha();
                    
                    console.log('Kiira Coin Blockchain initialized successfully');
                } catch (error) {
                    console.error('Initialization error:', error);
                    document.getElementById('loading-text').textContent = 'Initialization failed. Please refresh.';
                    document.getElementById('loading-details').textContent = error.message;
                }
            }
            
            async initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('KiiraCoinDB', 3);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('blocks')) {
                            db.createObjectStore('blocks', { keyPath: 'height' });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            db.createObjectStore('transactions', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('wallets')) {
                            db.createObjectStore('wallets', { keyPath: 'address' });
                        }
                        
                        if (!db.objectStoreNames.contains('peers')) {
                            db.createObjectStore('peers', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        if (!db.objectStoreNames.contains('referrals')) {
                            db.createObjectStore('referrals', { keyPath: 'code' });
                        }
                        
                        if (!db.objectStoreNames.contains('captchas')) {
                            db.createObjectStore('captchas', { keyPath: 'id' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        reject(new Error('Failed to open IndexedDB'));
                    };
                });
            }
            
            async initIPFS() {
                return new Promise((resolve, reject) => {
                    document.getElementById('loading-text').textContent = 'Initializing IPFS...';
                    
                    this.ipfs = new Ipfs({
                        repo: 'kiira-coin-' + Math.random(),
                        config: {
                            Addresses: {
                                Swarm: [
                                    '/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star',
                                    '/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star'
                                ]
                            },
                            Bootstrap: this.bootstrapNodes
                        }
                    });
                    
                    this.ipfs.on('ready', () => {
                        console.log('IPFS ready');
                        document.getElementById('loading-text').textContent = 'IPFS initialized. Connecting to peers...';
                        resolve();
                    });
                    
                    this.ipfs.on('error', (error) => {
                        console.error('IPFS error:', error);
                        reject(new Error('IPFS initialization failed'));
                    });
                });
            }
            
            async initPeerJS() {
                return new Promise((resolve, reject) => {
                    document.getElementById('loading-text').textContent = 'Initializing P2P network...';
                    
                    // Generate a random peer ID if none exists
                    const storedPeerId = localStorage.getItem('krc-peer-id');
                    this.peerId = storedPeerId || 'krc-' + Math.random().toString(36).substr(2, 9);
                    
                    if (!storedPeerId) {
                        localStorage.setItem('krc-peer-id', this.peerId);
                    }
                    
                    this.peer = new Peer(this.peerId);
                    
                    this.peer.on('open', (id) => {
                        console.log('PeerJS connected with ID:', id);
                        document.getElementById('loading-text').textContent = 'P2P network ready. Loading wallet...';
                        resolve();
                    });
                    
                    this.peer.on('connection', (conn) => {
                        console.log('Peer connected:', conn.peer);
                        this.handlePeerConnection(conn);
                    });
                    
                    this.peer.on('error', (error) => {
                        console.error('PeerJS error:', error);
                        reject(new Error('P2P network initialization failed'));
                    });
                });
            }
            
            async loadOrCreateWallet() {
                return new Promise((resolve, reject) => {
                    document.getElementById('loading-text').textContent = 'Loading wallet...';
                    
                    const walletData = localStorage.getItem('krc-wallet');
                    
                    if (walletData) {
                        try {
                            const wallet = JSON.parse(walletData);
                            this.keyPair = this.ec.keyFromPrivate(wallet.privateKey);
                            this.walletAddress = wallet.address;
                            this.isSuperAdmin = wallet.isSuperAdmin || false;
                            
                            console.log('Wallet loaded:', this.walletAddress);
                            resolve();
                        } catch (error) {
                            console.error('Error loading wallet:', error);
                            this.createNewWallet().then(resolve).catch(reject);
                        }
                    } else {
                        this.createNewWallet().then(resolve).catch(reject);
                    }
                });
            }
            
            async createNewWallet() {
                return new Promise((resolve) => {
                    document.getElementById('loading-text').textContent = 'Creating new wallet...';
                    
                    // Generate new key pair
                    this.keyPair = this.ec.genKeyPair();
                    const privateKey = this.keyPair.getPrivate('hex');
                    const publicKey = this.keyPair.getPublic('hex');
                    this.walletAddress = this.generateAddress(publicKey);
                    
                    // Check if this is the first wallet (super admin)
                    this.isSuperAdmin = this.blocks.length === 0;
                    
                    // Save wallet to localStorage
                    localStorage.setItem('krc-wallet', JSON.stringify({
                        privateKey,
                        address: this.walletAddress,
                        isSuperAdmin: this.isSuperAdmin
                    }));
                    
                    console.log('New wallet created:', this.walletAddress, 'Super admin:', this.isSuperAdmin);
                    
                    // If super admin, add initial balance
                    if (this.isSuperAdmin) {
                        const initialBalance = this.totalSupply * this.superAdminInitialReward;
                        this.addTransaction({
                            from: 'genesis',
                            to: this.walletAddress,
                            amount: initialBalance,
                            memo: 'Super admin initial reward',
                            timestamp: Date.now()
                        }).then(() => {
                            resolve();
                        });
                    } else {
                        // For regular users, wait for the referral reward
                        resolve();
                    }
                });
            }
            
            async loadBlockchain() {
                return new Promise((resolve, reject) => {
                    document.getElementById('loading-text').textContent = 'Loading blockchain...';
                    
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        this.blocks = event.target.result || [];
                        
                        if (this.blocks.length === 0) {
                            console.log('No blocks found, creating genesis block');
                            this.createGenesisBlock().then(resolve).catch(reject);
                        } else {
                            console.log('Loaded', this.blocks.length, 'blocks from DB');
                            this.currentBlock = this.blocks[this.blocks.length - 1];
                            resolve();
                        }
                    };
                    
                    request.onerror = (event) => {
                        reject(new Error('Failed to load blocks from DB'));
                    };
                });
            }
            
            async createGenesisBlock() {
                return new Promise((resolve) => {
                    document.getElementById('loading-text').textContent = 'Creating genesis block...';
                    
                    const genesisBlock = {
                        height: 0,
                        timestamp: Date.now(),
                        transactions: [],
                        previousHash: '0',
                        hash: this.calculateBlockHash(0, '0', [], Date.now()),
                        validator: 'genesis',
                        signature: 'genesis'
                    };
                    
                    this.blocks.push(genesisBlock);
                    this.currentBlock = genesisBlock;
                    
                    // Save to DB
                    const transaction = this.db.transaction(['blocks'], 'readwrite');
                    const store = transaction.objectStore('blocks');
                    store.add(genesisBlock);
                    
                    console.log('Genesis block created');
                    resolve();
                });
            }
            
            async initNetwork() {
                document.getElementById('loading-text').textContent = 'Connecting to network...';
                
                // Connect to bootstrap nodes
                for (const node of this.bootstrapNodes) {
                    try {
                        await this.connectToPeer(node);
                    } catch (error) {
                        console.error('Failed to connect to bootstrap node:', node, error);
                    }
                }
                
                // Load known peers from DB
                await this.loadKnownPeers();
                
                // Start peer discovery
                this.startPeerDiscovery();
                
                // Sync blockchain with peers
                this.syncBlockchain();
            }
            
            async loadKnownPeers() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readonly');
                    const store = transaction.objectStore('peers');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        this.peers = event.target.result || [];
                        console.log('Loaded', this.peers.length, 'known peers from DB');
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        reject(new Error('Failed to load peers from DB'));
                    };
                });
            }
            
            startPeerDiscovery() {
                // Use IPFS for peer discovery
                setInterval(() => {
                    this.ipfs.swarm.peers((error, peers) => {
                        if (error) {
                            console.error('IPFS peer discovery error:', error);
                            return;
                        }
                        
                        peers.forEach((peer) => {
                            const peerAddr = peer.addr.toString();
                            if (!this.peers.some(p => p.id === peer.peer)) {
                                this.addPeer({
                                    id: peer.peer,
                                    address: peerAddr,
                                    lastSeen: Date.now()
                                });
                            }
                        });
                    });
                }, 30000);
            }
            
            async connectToPeer(peerAddress) {
                return new Promise((resolve, reject) => {
                    const conn = this.peer.connect(peerAddress, {
                        reliable: true,
                        serialization: 'json'
                    });
                    
                    conn.on('open', () => {
                        console.log('Connected to peer:', peerAddress);
                        this.handlePeerConnection(conn);
                        resolve();
                    });
                    
                    conn.on('error', (error) => {
                        console.error('Connection error:', error);
                        reject(error);
                    });
                });
            }
            
            handlePeerConnection(conn) {
                const peerId = conn.peer;
                
                // Add to connected peers if not already present
                if (!this.connectedPeers.some(p => p.id === peerId)) {
                    this.connectedPeers.push({
                        id: peerId,
                        connection: conn,
                        lastSeen: Date.now()
                    });
                    
                    this.updatePeerList();
                }
                
                // Handle incoming messages
                conn.on('data', (data) => {
                    this.handlePeerMessage(conn, data);
                });
                
                conn.on('close', () => {
                    console.log('Connection closed with peer:', peerId);
                    this.connectedPeers = this.connectedPeers.filter(p => p.id !== peerId);
                    this.updatePeerList();
                });
                
                conn.on('error', (error) => {
                    console.error('Peer connection error:', error);
                    this.connectedPeers = this.connectedPeers.filter(p => p.id !== peerId);
                    this.updatePeerList();
                });
            }
            
            handlePeerMessage(conn, message) {
                console.log('Received message from peer:', message);
                
                switch (message.type) {
                    case 'hello':
                        this.handleHelloMessage(conn, message);
                        break;
                    case 'block':
                        this.handleBlockMessage(message);
                        break;
                    case 'transaction':
                        this.handleTransactionMessage(message);
                        break;
                    case 'sync-request':
                        this.handleSyncRequest(conn, message);
                        break;
                    case 'sync-response':
                        this.handleSyncResponse(message);
                        break;
                    case 'peer-list':
                        this.handlePeerListMessage(message);
                        break;
                    default:
                        console.warn('Unknown message type:', message.type);
                }
            }
            
            handleHelloMessage(conn, message) {
                // Send our peer list in response
                conn.send({
                    type: 'peer-list',
                    peers: this.peers
                });
            }
            
            handleBlockMessage(message) {
                const block = message.block;
                
                // Validate the block
                if (this.validateBlock(block)) {
                    // Add to blockchain if it's the next block
                    if (block.height === this.currentBlock.height + 1) {
                        this.addBlock(block);
                    } else if (block.height > this.currentBlock.height + 1) {
                        // We're behind, request sync
                        this.syncBlockchain();
                    }
                }
            }
            
            handleTransactionMessage(message) {
                const transaction = message.transaction;
                
                // Validate the transaction
                if (this.validateTransaction(transaction)) {
                    // Add to pending transactions
                    this.addPendingTransaction(transaction);
                }
            }
            
            handleSyncRequest(conn, message) {
                // Send blocks from requested height
                const fromHeight = message.fromHeight;
                const toHeight = Math.min(fromHeight + 100, this.currentBlock.height);
                
                const blocksToSend = [];
                for (let i = fromHeight; i <= toHeight; i++) {
                    const block = this.blocks.find(b => b.height === i);
                    if (block) {
                        blocksToSend.push(block);
                    }
                }
                
                conn.send({
                    type: 'sync-response',
                    blocks: blocksToSend,
                    fromHeight,
                    toHeight
                });
            }
            
            handleSyncResponse(message) {
                // Add received blocks to our chain
                message.blocks.forEach(block => {
                    if (this.validateBlock(block) {
                        this.addBlock(block);
                    }
                });
                
                // If we're still behind, request more blocks
                if (this.currentBlock.height < message.toHeight) {
                    this.syncBlockchain(message.toHeight + 1);
                }
            }
            
            handlePeerListMessage(message) {
                // Add new peers to our list
                message.peers.forEach(peer => {
                    if (!this.peers.some(p => p.id === peer.id)) {
                        this.addPeer(peer);
                    }
                });
            }
            
            async addPeer(peer) {
                // Add to memory
                this.peers.push(peer);
                
                // Save to DB
                const transaction = this.db.transaction(['peers'], 'readwrite');
                const store = transaction.objectStore('peers');
                store.put(peer);
                
                // Try to connect
                try {
                    await this.connectToPeer(peer.address);
                } catch (error) {
                    console.error('Failed to connect to peer:', peer.address, error);
                }
            }
            
            async syncBlockchain(fromHeight = this.currentBlock.height + 1) {
                if (this.connectedPeers.length === 0) {
                    console.log('No peers connected to sync with');
                    return;
                }
                
                console.log('Syncing blockchain from height', fromHeight);
                
                // Select a random peer to sync with
                const peer = this.connectedPeers[Math.floor(Math.random() * this.connectedPeers.length)];
                
                peer.connection.send({
                    type: 'sync-request',
                    fromHeight
                });
            }
            
            startBlockchain() {
                // Start block production
                setInterval(() => {
                    this.produceBlock();
                }, this.blockTime * 1000);
                
                // Broadcast our presence
                setInterval(() => {
                    this.broadcastHello();
                }, 30000);
                
                // Broadcast pending transactions
                setInterval(() => {
                    this.broadcastPendingTransactions();
                }, 10000);
                
                // Initial broadcast
                this.broadcastHello();
            }
            
            broadcastHello() {
                const message = {
                    type: 'hello',
                    peerId: this.peerId,
                    address: this.walletAddress,
                    blockHeight: this.currentBlock.height,
                    timestamp: Date.now()
                };
                
                this.broadcastMessage(message);
            }
            
            broadcastBlock(block) {
                const message = {
                    type: 'block',
                    block,
                    timestamp: Date.now()
                };
                
                this.broadcastMessage(message);
            }
            
            broadcastTransaction(transaction) {
                const message = {
                    type: 'transaction',
                    transaction,
                    timestamp: Date.now()
                };
                
                this.broadcastMessage(message);
            }
            
            broadcastPendingTransactions() {
                this.pendingTransactions.forEach(transaction => {
                    this.broadcastTransaction(transaction);
                });
            }
            
            broadcastMessage(message) {
                this.connectedPeers.forEach(peer => {
                    try {
                        peer.connection.send(message);
                    } catch (error) {
                        console.error('Failed to send message to peer:', peer.id, error);
                    }
                });
            }
            
            async produceBlock() {
                // Select validator
                const validator = await this.selectValidator();
                
                // If we're the validator, create a new block
                if (validator === this.walletAddress && this.pendingTransactions.length > 0) {
                    console.log('We are the validator, producing new block');
                    
                    const transactions = [...this.pendingTransactions];
                    this.pendingTransactions = [];
                    
                    const newBlock = {
                        height: this.currentBlock.height + 1,
                        timestamp: Date.now(),
                        transactions,
                        previousHash: this.currentBlock.hash,
                        validator: this.walletAddress
                    };
                    
                    // Calculate hash and sign the block
                    newBlock.hash = this.calculateBlockHash(newBlock.height, newBlock.previousHash, newBlock.transactions, newBlock.timestamp);
                    newBlock.signature = this.signData(newBlock.hash);
                    
                    // Add to blockchain
                    await this.addBlock(newBlock);
                    
                    // Broadcast the new block
                    this.broadcastBlock(newBlock);
                }
            }
            
            async selectValidator() {
                // Get all staked wallets
                const stakedWallets = await this.getStakedWallets();
                
                if (stakedWallets.length === 0) {
                    return this.walletAddress; // Fallback to our address if no stakes
                }
                
                // Calculate total stake
                const totalStake = stakedWallets.reduce((sum, wallet) => sum + wallet.stake, 0);
                
                // Select validator based on stake weight and randomization
                let random = Math.random() * totalStake;
                let selectedValidator = stakedWallets[0].address;
                
                for (const wallet of stakedWallets) {
                    random -= wallet.stake;
                    if (random <= 0) {
                        selectedValidator = wallet.address;
                        break;
                    }
                }
                
                return selectedValidator;
            }
            
            async getStakedWallets() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readonly');
                    const store = transaction.objectStore('wallets');
                    const request = store.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result || [];
                        const stakedWallets = wallets
                            .filter(wallet => wallet.stake > 0)
                            .map(wallet => ({
                                address: wallet.address,
                                stake: wallet.stake || 0
                            }));
                        
                        resolve(stakedWallets);
                    };
                    
                    request.onerror = (event) => {
                        reject(new Error('Failed to get staked wallets'));
                    };
                });
            }
            
            async addBlock(block) {
                // Validate the block
                if (!this.validateBlock(block)) {
                    console.error('Invalid block received:', block);
                    return false;
                }
                
                // Check if we already have this block
                const existingBlock = this.blocks.find(b => b.height === block.height);
                if (existingBlock) {
                    if (existingBlock.hash === block.hash) {
                        return true; // Already have this block
                    } else {
                        // Fork detected, resolve by choosing the longest chain
                        return this.resolveFork(block);
                    }
                }
                
                // Add to blockchain
                this.blocks.push(block);
                this.currentBlock = block;
                
                // Save to DB
                const transaction = this.db.transaction(['blocks'], 'readwrite');
                const store = transaction.objectStore('blocks');
                store.put(block);
                
                // Process transactions in the block
                for (const tx of block.transactions) {
                    await this.processTransaction(tx);
                }
                
                // Reward the validator
                if (block.height > 0) { // Skip genesis block
                    await this.rewardValidator(block.validator);
                }
                
                console.log('Block added:', block.height);
                return true;
            }
            
            async resolveFork(newBlock) {
                // Get all blocks at the fork height
                const forkBlocks = this.blocks.filter(b => b.height === newBlock.height);
                
                if (forkBlocks.length === 0) {
                    // No fork at this height, just add the new block
                    return this.addBlock(newBlock);
                }
                
                // For now, we'll just keep the first block we received
                console.log('Fork detected at height', newBlock.height, 'keeping existing block');
                return false;
            }
            
            validateBlock(block) {
                // Validate block structure
                if (!block.height || !block.timestamp || !block.transactions || !block.previousHash || !block.hash || !block.validator || !block.signature) {
                    console.error('Block missing required fields');
                    return false;
                }
                
                // Validate hash
                const calculatedHash = this.calculateBlockHash(block.height, block.previousHash, block.transactions, block.timestamp);
                if (calculatedHash !== block.hash) {
                    console.error('Invalid block hash');
                    return false;
                }
                
                // Validate signature
                const validatorPublicKey = this.addressToPublicKey(block.validator);
                if (!validatorPublicKey || !this.verifySignature(block.hash, block.signature, validatorPublicKey)) {
                    console.error('Invalid block signature');
                    return false;
                }
                
                // Validate transactions
                for (const tx of block.transactions) {
                    if (!this.validateTransaction(tx)) {
                        console.error('Invalid transaction in block:', tx);
                        return false;
                    }
                }
                
                return true;
            }
            
            calculateBlockHash(height, previousHash, transactions, timestamp) {
                const txString = transactions.map(tx => tx.id).join('');
                const data = `${height}${previousHash}${txString}${timestamp}`;
                return CryptoJS.SHA256(data).toString();
            }
            
            async addPendingTransaction(transaction) {
                // Check if already in pending
                if (this.pendingTransactions.some(tx => tx.id === transaction.id)) {
                    return false;
                }
                
                // Validate the transaction
                if (!this.validateTransaction(transaction)) {
                    return false;
                }
                
                // Add to pending
                this.pendingTransactions.push(transaction);
                
                // Save to DB
                const txStore = this.db.transaction(['transactions'], 'readwrite').objectStore('transactions');
                txStore.put(transaction);
                
                return true;
            }
            
            validateTransaction(transaction) {
                // Basic validation
                if (!transaction.id || !transaction.from || !transaction.to || !transaction.amount || 
                    !transaction.timestamp || !transaction.signature) {
                    console.error('Transaction missing required fields');
                    return false;
                }
                
                // Validate amount
                if (transaction.amount <= 0 || transaction.amount > this.totalSupply) {
                    console.error('Invalid transaction amount');
                    return false;
                }
                
                // Validate signature
                const fromPublicKey = this.addressToPublicKey(transaction.from);
                if (!fromPublicKey) {
                    console.error('Could not get public key for address:', transaction.from);
                    return false;
                }
                
                const txData = this.getTransactionDataToSign(transaction);
                if (!this.verifySignature(txData, transaction.signature, fromPublicKey)) {
                    console.error('Invalid transaction signature');
                    return false;
                }
                
                // For non-genesis transactions, check sender balance
                if (transaction.from !== 'genesis') {
                    const senderBalance = this.getWalletBalance(transaction.from);
                    if (senderBalance < transaction.amount) {
                        console.error('Insufficient balance for transaction');
                        return false;
                    }
                }
                
                return true;
            }
            
            async processTransaction(transaction) {
                // Skip if already processed
                const existingTx = await this.getTransaction(transaction.id);
                if (existingTx) {
                    return;
                }
                
                // Update sender balance (skip for genesis transactions)
                if (transaction.from !== 'genesis') {
                    await this.updateWalletBalance(transaction.from, -transaction.amount);
                }
                
                // Update recipient balance
                await this.updateWalletBalance(transaction.to, transaction.amount);
                
                // Save transaction
                const txStore = this.db.transaction(['transactions'], 'readwrite').objectStore('transactions');
                txStore.put(transaction);
                
                // If this is a new user's first transaction (from genesis), give referral reward
                if (transaction.from === 'genesis' && transaction.memo === 'New user reward') {
                    const referralCode = transaction.memo.split(' ')[2]; // "New user reward REF123"
                    if (referralCode) {
                        await this.processReferralReward(transaction.to, referralCode);
                    }
                }
            }
            
            async rewardValidator(validatorAddress) {
                // Get current reward rate from settings
                const rewardAmount = this.stakeReward;
                
                // Create reward transaction
                const rewardTx = {
                    from: 'genesis',
                    to: validatorAddress,
                    amount: rewardAmount,
                    memo: 'Validator reward',
                    timestamp: Date.now(),
                    id: this.generateTransactionId('genesis', validatorAddress, rewardAmount, Date.now())
                };
                
                // Add to pending transactions
                await this.addPendingTransaction(rewardTx);
            }
            
            async processReferralReward(newUserAddress, referralCode) {
                // Find the referrer
                const referrer = await this.getReferrer(referralCode);
                if (!referrer) {
                    return;
                }
                
                // Calculate reward (10% of new user's initial balance)
                const newUserBalance = this.getWalletBalance(newUserAddress);
                const rewardAmount = newUserBalance * this.referralReward;
                
                // Create referral reward transaction
                const referralTx = {
                    from: 'genesis',
                    to: referrer,
                    amount: rewardAmount,
                    memo: `Referral reward for ${newUserAddress}`,
                    timestamp: Date.now(),
                    id: this.generateTransactionId('genesis', referrer, rewardAmount, Date.now())
                };
                
                // Add to pending transactions
                await this.addPendingTransaction(referralTx);
                
                // Update referral stats
                await this.updateReferralStats(referrer, newUserAddress, rewardAmount);
            }
            
            async updateReferralStats(referrer, referredUser, rewardAmount) {
                // Get current stats
                const referral = await this.getReferral(referrer);
                
                // Update stats
                const updatedReferral = {
                    code: referrer,
                    referredUsers: [...(referral?.referredUsers || []), referredUser],
                    totalEarned: (referral?.totalEarned || 0) + rewardAmount,
                    lastReward: Date.now()
                };
                
                // Save to DB
                const referralStore = this.db.transaction(['referrals'], 'readwrite').objectStore('referrals');
                referralStore.put(updatedReferral);
            }
            
            async getReferral(referrer) {
                return new Promise((resolve) => {
                    const referralStore = this.db.transaction(['referrals'], 'readonly').objectStore('referrals');
                    const request = referralStore.get(referrer);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = () => {
                        resolve(null);
                    };
                });
            }
            
            async getReferrer(referralCode) {
                // In this simple implementation, the referral code is the referrer's address
                // In a real implementation, you'd have a mapping of codes to addresses
                return referralCode;
            }
            
            async getTransaction(transactionId) {
                return new Promise((resolve) => {
                    const txStore = this.db.transaction(['transactions'], 'readonly').objectStore('transactions');
                    const request = txStore.get(transactionId);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = () => {
                        resolve(null);
                    };
                });
            }
            
            async getWalletBalance(address) {
                return new Promise((resolve) => {
                    const walletStore = this.db.transaction(['wallets'], 'readonly').objectStore('wallets');
                    const request = walletStore.get(address);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result?.balance || 0);
                    };
                    
                    request.onerror = () => {
                        resolve(0);
                    };
                });
            }
            
            async updateWalletBalance(address, amount) {
                // Get current balance
                const currentBalance = await this.getWalletBalance(address);
                const newBalance = currentBalance + amount;
                
                // Update wallet
                const wallet = {
                    address,
                    balance: newBalance,
                    publicKey: address === this.walletAddress ? this.keyPair.getPublic('hex') : undefined,
                    lastUpdated: Date.now()
                };
                
                // Save to DB
                const walletStore = this.db.transaction(['wallets'], 'readwrite').objectStore('wallets');
                walletStore.put(wallet);
                
                // Update UI if it's our wallet
                if (address === this.walletAddress) {
                    this.updateUI();
                }
            }
            
            async stakeKRC(amount) {
                // Check balance
                const balance = await this.getWalletBalance(this.walletAddress);
                if (amount > balance) {
                    throw new Error('Insufficient balance');
                }
                
                // Update stake amount
                const wallet = {
                    address: this.walletAddress,
                    balance: balance - amount,
                    stake: (await this.getStakeAmount()) + amount,
                    publicKey: this.keyPair.getPublic('hex'),
                    lastUpdated: Date.now()
                };
                
                // Save to DB
                const walletStore = this.db.transaction(['wallets'], 'readwrite').objectStore('wallets');
                walletStore.put(wallet);
                
                // Update UI
                this.updateUI();
            }
            
            async unstakeKRC(amount) {
                // Check staked amount
                const staked = await this.getStakeAmount();
                if (amount > staked) {
                    throw new Error('Insufficient staked amount');
                }
                
                // Update stake amount and balance
                const balance = await this.getWalletBalance(this.walletAddress);
                const wallet = {
                    address: this.walletAddress,
                    balance: balance + amount,
                    stake: staked - amount,
                    publicKey: this.keyPair.getPublic('hex'),
                    lastUpdated: Date.now()
                };
                
                // Save to DB
                const walletStore = this.db.transaction(['wallets'], 'readwrite').objectStore('wallets');
                walletStore.put(wallet);
                
                // Update UI
                this.updateUI();
            }
            
            async getStakeAmount() {
                return new Promise((resolve) => {
                    const walletStore = this.db.transaction(['wallets'], 'readonly').objectStore('wallets');
                    const request = walletStore.get(this.walletAddress);
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result?.stake || 0);
                    };
                    
                    request.onerror = () => {
                        resolve(0);
                    };
                });
            }
            
            generateAddress(publicKey) {
                // Simple address generation for demo purposes
                // In a real implementation, you'd use a more secure method
                const hash = CryptoJS.SHA256(publicKey).toString();
                return 'KRC' + hash.substring(0, 37); // KRC + 37 chars = 40 chars total
            }
            
            addressToPublicKey(address) {
                // In a real implementation, you'd have a mapping of addresses to public keys
                // For this demo, we only know our own public key
                if (address === this.walletAddress) {
                    return this.keyPair.getPublic('hex');
                }
                
                // For other addresses, we'd need to look them up in the wallet DB
                return null;
            }
            
            generateTransactionId(from, to, amount, timestamp) {
                return CryptoJS.SHA256(`${from}${to}${amount}${timestamp}`).toString();
            }
            
            getTransactionDataToSign(transaction) {
                // Data that needs to be signed for a transaction
                return `${transaction.from}${transaction.to}${transaction.amount}${transaction.timestamp}`;
            }
            
            signData(data) {
                const keyPair = this.keyPair;
                const signature = keyPair.sign(data, 'hex');
                return signature.toDER('hex');
            }
            
            verifySignature(data, signature, publicKey) {
                try {
                    const key = this.ec.keyFromPublic(publicKey, 'hex');
                    return key.verify(data, signature);
                } catch (error) {
                    console.error('Signature verification error:', error);
                    return false;
                }
            }
            
            async createTransaction(to, amount, memo = '') {
                // Check balance
                const balance = await this.getWalletBalance(this.walletAddress);
                if (amount > balance) {
                    throw new Error('Insufficient balance');
                }
                
                // Create transaction object
                const timestamp = Date.now();
                const transaction = {
                    from: this.walletAddress,
                    to,
                    amount,
                    memo,
                    timestamp,
                    id: this.generateTransactionId(this.walletAddress, to, amount, timestamp)
                };
                
                // Sign the transaction
                const txData = this.getTransactionDataToSign(transaction);
                transaction.signature = this.signData(txData);
                
                return transaction;
            }
            
            async sendTransaction(to, amount, memo = '') {
                const transaction = await this.createTransaction(to, amount, memo);
                
                // Add to pending transactions
                await this.addPendingTransaction(transaction);
                
                // Broadcast the transaction
                this.broadcastTransaction(transaction);
                
                return transaction;
            }
            
            async getRemainingSupply() {
                // Calculate remaining supply by summing all wallet balances and subtracting from total supply
                return new Promise((resolve) => {
                    const walletStore = this.db.transaction(['wallets'], 'readonly').objectStore('wallets');
                    const request = walletStore.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result || [];
                        const totalDistributed = wallets.reduce((sum, wallet) => sum + wallet.balance, 0);
                        resolve(this.totalSupply - totalDistributed);
                    };
                    
                    request.onerror = () => {
                        resolve(this.totalSupply);
                    };
                });
            }
            
            async getTotalCirculating() {
                return new Promise((resolve) => {
                    const walletStore = this.db.transaction(['wallets'], 'readonly').objectStore('wallets');
                    const request = walletStore.getAll();
                    
                    request.onsuccess = (event) => {
                        const wallets = event.target.result || [];
                        const total = wallets.reduce((sum, wallet) => sum + wallet.balance, 0);
                        resolve(total);
                    };
                    
                    request.onerror = () => {
                        resolve(0);
                    };
                });
            }
            
            async getTotalTransactions() {
                return new Promise((resolve) => {
                    const txStore = this.db.transaction(['transactions'], 'readonly').objectStore('transactions');
                    const request = txStore.count();
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = () => {
                        resolve(0);
                    };
                });
            }
            
            async getRecentTransactions(count = 10) {
                return new Promise((resolve) => {
                    const txStore = this.db.transaction(['transactions'], 'readonly').objectStore('transactions');
                    const request = txStore.getAll();
                    
                    request.onsuccess = (event) => {
                        const transactions = event.target.result || [];
                        // Sort by timestamp descending
                        transactions.sort((a, b) => b.timestamp - a.timestamp);
                        resolve(transactions.slice(0, count));
                    };
                    
                    request.onerror = () => {
                        resolve([]);
                    };
                });
            }
            
            generateCaptcha() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                
                // Store the solution
                this.captchaSolutions[result] = true;
                
                return result;
            }
            
            verifyCaptcha(solution) {
                if (this.captchaSolutions[solution]) {
                    // Remove the used CAPTCHA
                    delete this.captchaSolutions[solution];
                    return true;
                }
                return false;
            }
            
            async rewardCaptchaSolver() {
                // Get current reward rate from settings
                const rewardAmount = this.captchaReward;
                
                // Create reward transaction
                const rewardTx = {
                    from: 'genesis',
                    to: this.walletAddress,
                    amount: rewardAmount,
                    memo: 'CAPTCHA reward',
                    timestamp: Date.now(),
                    id: this.generateTransactionId('genesis', this.walletAddress, rewardAmount, Date.now())
                };
                
                // Add to pending transactions
                await this.addPendingTransaction(rewardTx);
                
                // Update CAPTCHA stats
                await this.updateCaptchaStats(rewardAmount);
            }
            
            async updateCaptchaStats(rewardAmount) {
                // Get current stats
                const stats = await this.getCaptchaStats();
                
                // Update stats
                const updatedStats = {
                    id: 'captcha-stats',
                    totalSolved: (stats?.totalSolved || 0) + 1,
                    totalEarned: (stats?.totalEarned || 0) + rewardAmount,
                    lastSolved: Date.now()
                };
                
                // Save to DB
                const captchaStore = this.db.transaction(['captchas'], 'readwrite').objectStore('captchas');
                captchaStore.put(updatedStats);
            }
            
            async getCaptchaStats() {
                return new Promise((resolve) => {
                    const captchaStore = this.db.transaction(['captchas'], 'readonly').objectStore('captchas');
                    const request = captchaStore.get('captcha-stats');
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = () => {
                        resolve(null);
                    };
                });
            }
            
            async rewardOnlineTime(minutes) {
                // Calculate reward based on online time
                const rewardAmount = minutes * this.onlineReward;
                
                if (rewardAmount <= 0) {
                    return;
                }
                
                // Create reward transaction
                const rewardTx = {
                    from: 'genesis',
                    to: this.walletAddress,
                    amount: rewardAmount,
                    memo: 'Online time reward',
                    timestamp: Date.now(),
                    id: this.generateTransactionId('genesis', this.walletAddress, rewardAmount, Date.now())
                };
                
                // Add to pending transactions
                await this.addPendingTransaction(rewardTx);
                
                // Update online time stats
                await this.updateOnlineTimeStats(minutes, rewardAmount);
            }
            
            async updateOnlineTimeStats(minutes, rewardAmount) {
                // Get current stats
                const stats = await this.getOnlineTimeStats();
                
                // Update stats
                const today = new Date().toISOString().split('T')[0];
                const updatedStats = {
                    id: 'online-stats',
                    totalMinutes: (stats?.totalMinutes || 0) + minutes,
                    totalEarned: (stats?.totalEarned || 0) + rewardAmount,
                    dailyMinutes: {
                        ...(stats?.dailyMinutes || {}),
                        [today]: (stats?.dailyMinutes?.[today] || 0) + minutes
                    },
                    lastUpdated: Date.now()
                };
                
                // Save to DB
                const onlineStore = this.db.transaction(['captchas'], 'readwrite').objectStore('captchas');
                onlineStore.put(updatedStats);
            }
            
            async getOnlineTimeStats() {
                return new Promise((resolve) => {
                    const onlineStore = this.db.transaction(['captchas'], 'readonly').objectStore('captchas');
                    const request = onlineStore.get('online-stats');
                    
                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };
                    
                    request.onerror = () => {
                        resolve(null);
                    };
                });
            }
            
            startOnlineTimeTracking() {
                // Track online time
                let lastActive = Date.now();
                
                // Update every minute
                this.onlineTimer = setInterval(async () => {
                    const now = Date.now();
                    const minutesActive = Math.floor((now - lastActive) / 60000);
                    
                    if (minutesActive > 0) {
                        this.onlineMinutes += minutesActive;
                        lastActive = now;
                        
                        // Reward online time
                        await this.rewardOnlineTime(minutesActive);
                        
                        // Update UI
                        this.updateUI();
                    }
                }, 60000); // Check every minute
                
                // Track window focus/blur to detect active usage
                window.addEventListener('focus', () => {
                    lastActive = Date.now();
                });
                
                window.addEventListener('blur', () => {
                    const now = Date.now();
                    const minutesActive = Math.floor((now - lastActive) / 60000);
                    
                    if (minutesActive > 0) {
                        this.onlineMinutes += minutesActive;
                        this.rewardOnlineTime(minutesActive);
                    }
                });
            }
            
            async generateReferralCode() {
                // Simple referral code generation (just using address for now)
                return this.walletAddress;
            }
            
            async getReferralStats() {
                return this.getReferral(this.walletAddress);
            }
            
            // UI Update Methods
            updateUI() {
                this.updateBalance();
                this.updateAddress();
                this.updateRecentTransactions();
                this.updatePeerList();
                this.updateBlockHeight();
                this.updateSupplyInfo();
                this.updateValidatorStatus();
                this.updateReferralInfo();
                this.updateCaptchaInfo();
                this.updateOnlineTimeInfo();
                this.updateAdminUI();
            }
            
            async updateBalance() {
                const balance = await this.getWalletBalance(this.walletAddress);
                const formattedBalance = this.formatKRC(balance);
                
                document.getElementById('account-balance').textContent = formattedBalance + ' KRC';
                document.getElementById('wallet-balance').textContent = formattedBalance + ' KRC';
                
                if (this.isSuperAdmin) {
                    document.getElementById('admin-balance').textContent = formattedBalance + ' KRC';
                }
            }
            
            async updateAddress() {
                document.getElementById('account-address').textContent = this.walletAddress;
                document.getElementById('wallet-address').textContent = this.walletAddress;
                document.getElementById('receive-address').textContent = this.walletAddress;
                
                // Generate QR code
                this.generateQRCode(this.walletAddress, 'qr-code');
                
                // Update referral link
                const referralCode = await this.generateReferralCode();
                const referralLink = `${window.location.origin}${window.location.pathname}?ref=${referralCode}`;
                document.getElementById('referral-link').textContent = referralLink;
            }
            
            generateQRCode(text, elementId) {
                const qrElement = document.getElementById(elementId);
                qrElement.innerHTML = '';
                
                // Simple QR code generation using canvas
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 200;
                
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Simple QR pattern (in a real app, use a library)
                ctx.fillStyle = 'black';
                const blockSize = 10;
                const data = text.split('');
                
                for (let i = 0; i < data.length; i++) {
                    const x = (i % 20) * blockSize;
                    const y = Math.floor(i / 20) * blockSize;
                    
                    if (i % 3 === 0 || i % 7 === 0) { // Simple pattern
                        ctx.fillRect(x, y, blockSize, blockSize);
                    }
                }
                
                qrElement.appendChild(canvas);
            }
            
            async updateRecentTransactions() {
                const transactions = await this.getRecentTransactions(5);
                const container = document.getElementById('recent-transactions');
                
                if (transactions.length === 0) {
                    container.innerHTML = '<p>No recent transactions</p>';
                    return;
                }
                
                let html = '<table><thead><tr><th>Type</th><th>Amount</th><th>From/To</th><th>Date</th></tr></thead><tbody>';
                
                transactions.forEach(tx => {
                    const isIncoming = tx.to === this.walletAddress;
                    const type = isIncoming ? 'Received' : 'Sent';
                    const amountClass = isIncoming ? 'text-success' : 'text-error';
                    const otherAddress = isIncoming ? tx.from : tx.to;
                    const amount = this.formatKRC(tx.amount);
                    
                    html += `
                        <tr>
                            <td>${type}</td>
                            <td class="${amountClass}">${isIncoming ? '+' : '-'}${amount} KRC</td>
                            <td>${otherAddress}</td>
                            <td>${new Date(tx.timestamp).toLocaleString()}</td>
                        </tr>
                    `;
                });
                
                html += '</tbody></table>';
                container.innerHTML = html;
            }
            
            async updateTransactionHistory() {
                const transactions = await this.getRecentTransactions(50);
                const container = document.getElementById('transaction-list');
                
                if (transactions.length === 0) {
                    container.innerHTML = '<tr><td colspan="6">No transactions found</td></tr>';
                    return;
                }
                
                let html = '';
                
                transactions.forEach(tx => {
                    const isIncoming = tx.to === this.walletAddress;
                    const type = isIncoming ? 'Incoming' : 'Outgoing';
                    const amountClass = isIncoming ? 'badge-success' : 'badge-error';
                    const otherAddress = isIncoming ? tx.from : tx.to;
                    const amount = this.formatKRC(tx.amount);
                    const status = tx.blockHeight ? 'Confirmed' : 'Pending';
                    const statusClass = tx.blockHeight ? 'badge-success' : 'badge-warning';
                    
                    html += `
                        <tr>
                            <td>${tx.id.substring(0, 8)}...</td>
                            <td><span class="badge ${amountClass}">${type}</span></td>
                            <td>${amount} KRC</td>
                            <td>${otherAddress}</td>
                            <td>${new Date(tx.timestamp).toLocaleString()}</td>
                            <td><span class="badge ${statusClass}">${status}</span></td>
                        </tr>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            async updatePeerList() {
                const container = document.getElementById('peer-list');
                const peerCount = this.connectedPeers.length;
                
                document.getElementById('peer-count').textContent = peerCount;
                document.getElementById('connected-peers-count').textContent = peerCount;
                
                if (peerCount === 0) {
                    container.innerHTML = '<tr><td colspan="5">No peers connected</td></tr>';
                    return;
                }
                
                let html = '';
                
                this.connectedPeers.forEach(peer => {
                    const lastSeen = new Date(peer.lastSeen).toLocaleTimeString();
                    const stake = this.validatorNodes[peer.id] || 0;
                    
                    html += `
                        <tr>
                            <td>${peer.id.substring(0, 8)}...</td>
                            <td>${peer.id}</td>
                            <td><span class="peer-status"><span class="peer-status-indicator"></span> Connected</span></td>
                            <td>${lastSeen}</td>
                            <td>${this.formatKRC(stake)} KRC</td>
                        </tr>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            async updateBlockHeight() {
                document.getElementById('block-height').textContent = this.currentBlock.height;
                document.getElementById('current-block-height').textContent = this.currentBlock.height;
            }
            
            async updateSupplyInfo() {
                const circulating = await this.getTotalCirculating();
                const remaining = await this.getRemainingSupply();
                
                document.getElementById('circulating-supply').textContent = this.formatKRC(circulating);
                document.getElementById('remaining-supply').textContent = this.formatKRC(remaining);
            }
            
            async updateValidatorStatus() {
                const stakeAmount = await this.getStakeAmount();
                const isValidator = stakeAmount > 0;
                
                document.getElementById('staked-amount').textContent = this.formatKRC(stakeAmount);
                document.getElementById('validator-status-text').textContent = isValidator ? 'Active Validator' : 'Not a validator';
                
                if (isValidator) {
                    document.getElementById('validator-status-text').classList.add('badge-success');
                } else {
                    document.getElementById('validator-status-text').classList.remove('badge-success');
                }
            }
            
            async updateReferralInfo() {
                const stats = await this.getReferralStats();
                
                document.getElementById('referral-count').textContent = stats?.referredUsers?.length || 0;
                document.getElementById('referral-earnings').textContent = this.formatKRC(stats?.totalEarned || 0);
            }
            
            async updateCaptchaInfo() {
                const stats = await this.getCaptchaStats();
                
                document.getElementById('captcha-count').textContent = stats?.totalSolved || 0;
                document.getElementById('captcha-earnings').textContent = this.formatKRC(stats?.totalEarned || 0);
            }
            
            async updateOnlineTimeInfo() {
                const stats = await this.getOnlineTimeStats();
                const today = new Date().toISOString().split('T')[0];
                const minutesToday = stats?.dailyMinutes?.[today] || 0;
                const estimatedEarnings = minutesToday * this.onlineReward;
                
                document.getElementById('online-time-today').textContent = minutesToday;
                document.getElementById('online-earnings-today').textContent = this.formatKRC(estimatedEarnings);
                document.getElementById('online-earnings-total').textContent = this.formatKRC(stats?.totalEarned || 0);
            }
            
            async updateAdminUI() {
                if (!this.isSuperAdmin) {
                    document.getElementById('admin-nav-item').classList.add('hidden');
                    return;
                }
                
                document.getElementById('admin-nav-item').classList.remove('hidden');
                
                // Update admin stats
                const totalTx = await this.getTotalTransactions();
                document.getElementById('admin-total-tx').textContent = totalTx;
                
                // Update coin settings
                document.getElementById('coin-name').value = 'Kiira Coin';
                document.getElementById('coin-symbol').value = 'KRC';
                document.getElementById('total-supply-input').value = this.totalSupply;
                
                // Update reward settings
                document.getElementById('referral-reward').value = this.referralReward * 100;
                document.getElementById('captcha-reward').value = this.captchaReward;
                document.getElementById('online-reward').value = this.onlineReward;
                document.getElementById('validator-reward').value = this.stakeReward;
                
                // Update integration code
                const integrationCode = `
                    <!-- Kiira Coin Payment Integration -->
                    <script src="https://cdn.jsdelivr.net/npm/kiira-coin@1.0.0/kiira-coin.min.js"></script>
                    <script>
                        const krc = new KiiraCoin();
                        
                        // Initialize payment button
                        function initKiiraPayment(amount, callback) {
                            document.getElementById('pay-with-krc').addEventListener('click', async () => {
                                try {
                                    const tx = await krc.sendTransaction(
                                        'MERCHANT_ADDRESS', 
                                        amount,
                                        'Payment for goods/services'
                                    );
                                    callback(null, tx);
                                } catch (error) {
                                    callback(error);
                                }
                            });
                        }
                    </script>
                    <button id="pay-with-krc">Pay with Kiira Coin</button>
                `;
                
                document.getElementById('integration-code').value = integrationCode.trim();
                
                // Update API docs
                const apiDocs = `
                    Kiira Coin API Documentation
                    ============================
                    
                    Wallet API:
                    ----------
                    - getBalance(address): Returns balance for given address
                    - createTransaction(to, amount, memo): Creates a new transaction
                    - sendTransaction(to, amount, memo): Sends a transaction
                    
                    Blockchain API:
                    --------------
                    - getBlock(height): Returns block at given height
                    - getLatestBlocks(count): Returns latest blocks
                    - getTransaction(id): Returns transaction by ID
                    
                    Network API:
                    -----------
                    - getPeers(): Returns connected peers
                    - getValidatorNodes(): Returns active validator nodes
                    
                    Example:
                    --------
                    const krc = new KiiraCoin();
                    const balance = await krc.getBalance('KRC...');
                    const tx = await krc.sendTransaction('KRC...', 10, 'Payment');
                `;
                
                document.getElementById('api-docs').value = apiDocs.trim();
            }
            
            generateCaptcha() {
                const captcha = this.generateCaptcha();
                document.getElementById('captcha-text').textContent = captcha;
            }
            
            formatKRC(amount) {
                // Format amount with 8 decimal places
                return parseFloat(amount.toFixed(8)).toLocaleString();
            }
            
            // Event Handlers
            setupEventHandlers() {
                // Navigation
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        const section = link.getAttribute('data-section');
                        this.showSection(section);
                    });
                });
                
                // Tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        const tabName = tab.getAttribute('data-tab');
                        this.showTab(tabName);
                    });
                });
                
                // Quick actions
                document.getElementById('send-funds-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showSection('wallet');
                });
                
                document.getElementById('receive-funds-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showSection('wallet');
                });
                
                document.getElementById('stake-funds-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showSection('network');
                });
                
                document.getElementById('earn-krc-link').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.showSection('dashboard');
                });
                
                // Wallet actions
                document.getElementById('copy-address').addEventListener('click', () => {
                    navigator.clipboard.writeText(this.walletAddress);
                    alert('Address copied to clipboard!');
                });
                
                document.getElementById('copy-receive-address').addEventListener('click', () => {
                    navigator.clipboard.writeText(this.walletAddress);
                    alert('Address copied to clipboard!');
                });
                
                document.getElementById('copy-referral').addEventListener('click', () => {
                    const referralLink = document.getElementById('referral-link').textContent;
                    navigator.clipboard.writeText(referralLink);
                    alert('Referral link copied to clipboard!');
                });
                
                document.getElementById('export-wallet').addEventListener('click', () => {
                    const walletData = localStorage.getItem('krc-wallet');
                    if (walletData) {
                        const blob = new Blob([walletData], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'kiira-coin-wallet.json';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                });
                
                document.getElementById('send-button').addEventListener('click', async () => {
                    const to = document.getElementById('send-to').value.trim();
                    const amount = parseFloat(document.getElementById('send-amount').value);
                    const memo = document.getElementById('send-memo').value.trim();
                    
                    if (!to || !to.startsWith('KRC') || to.length !== 40) {
                        alert('Please enter a valid KRC address (starts with KRC, 40 chars)');
                        return;
                    }
                    
                    if (isNaN(amount) || amount <= 0) {
                        alert('Please enter a valid amount');
                        return;
                    }
                    
                    try {
                        const tx = await this.sendTransaction(to, amount, memo);
                        document.getElementById('send-result').innerHTML = `
                            <div class="alert alert-success">
                                Transaction sent! ID: ${tx.id.substring(0, 8)}...
                            </div>
                        `;
                        
                        // Clear form
                        document.getElementById('send-to').value = '';
                        document.getElementById('send-amount').value = '';
                        document.getElementById('send-memo').value = '';
                    } catch (error) {
                        document.getElementById('send-result').innerHTML = `
                            <div class="alert alert-error">
                                Error: ${error.message}
                            </div>
                        `;
                    }
                });
                
                // CAPTCHA
                document.getElementById('verify-captcha').addEventListener('click', async () => {
                    const captchaText = document.getElementById('captcha-text').textContent;
                    const userInput = document.getElementById('captcha-input').value.trim();
                    
                    if (userInput === captchaText) {
                        document.getElementById('captcha-result').innerHTML = `
                            <div class="alert alert-success">
                                CAPTCHA solved! You earned ${this.captchaReward} KRC
                            </div>
                        `;
                        
                        await this.rewardCaptchaSolver();
                        this.generateCaptcha();
                        document.getElementById('captcha-input').value = '';
                        
                        // Update UI
                        this.updateCaptchaInfo();
                        this.updateBalance();
                    } else {
                        document.getElementById('captcha-result').innerHTML = `
                            <div class="alert alert-error">
                                Incorrect CAPTCHA. Please try again.
                            </div>
                        `;
                        this.generateCaptcha();
                    }
                });
                
                // Staking
                document.getElementById('stake-button').addEventListener('click', async () => {
                    const amount = parseFloat(document.getElementById('stake-amount').value);
                    
                    if (isNaN(amount) || amount <= 0) {
                        alert('Please enter a valid amount');
                        return;
                    }
                    
                    try {
                        await this.stakeKRC(amount);
                        document.getElementById('stake-result').innerHTML = `
                            <div class="alert alert-success">
                                Successfully staked ${amount} KRC
                            </div>
                        `;
                        
                        document.getElementById('stake-amount').value = '';
                        this.updateValidatorStatus();
                        this.updateBalance();
                    } catch (error) {
                        document.getElementById('stake-result').innerHTML = `
                            <div class="alert alert-error">
                                Error: ${error.message}
                            </div>
                        `;
                    }
                });
                
                document.getElementById('unstake-button').addEventListener('click', async () => {
                    const amount = parseFloat(document.getElementById('stake-amount').value);
                    
                    if (isNaN(amount) || amount <= 0) {
                        alert('Please enter a valid amount');
                        return;
                    }
                    
                    try {
                        await this.unstakeKRC(amount);
                        document.getElementById('stake-result').innerHTML = `
                            <div class="alert alert-success">
                                Successfully unstaked ${amount} KRC
                            </div>
                        `;
                        
                        document.getElementById('stake-amount').value = '';
                        this.updateValidatorStatus();
                        this.updateBalance();
                    } catch (error) {
                        document.getElementById('stake-result').innerHTML = `
                            <div class="alert alert-error">
                                Error: ${error.message}
                            </div>
                        `;
                    }
                });
                
                // Admin settings
                document.getElementById('save-coin-settings').addEventListener('click', () => {
                    alert('Coin settings saved!');
                });
                
                document.getElementById('save-reward-settings').addEventListener('click', () => {
                    this.referralReward = parseFloat(document.getElementById('referral-reward').value) / 100;
                    this.captchaReward = parseFloat(document.getElementById('captcha-reward').value);
                    this.onlineReward = parseFloat(document.getElementById('online-reward').value);
                    this.stakeReward = parseFloat(document.getElementById('validator-reward').value);
                    
                    alert('Reward settings saved!');
                });
                
                document.getElementById('save-exchange-settings').addEventListener('click', () => {
                    alert('Exchange settings saved!');
                });
                
                document.getElementById('submit-to-exchanges').addEventListener('click', () => {
                    alert('Submission to exchanges initiated. This may take some time.');
                });
                
                document.getElementById('update-coin-icon').addEventListener('click', () => {
                    const iconUrl = document.getElementById('coin-icon-input').value;
                    if (iconUrl) {
                        document.getElementById('coin-icon').src = iconUrl;
                        alert('Coin icon updated!');
                    }
                });
                
                document.getElementById('copy-integration-code').addEventListener('click', () => {
                    const code = document.getElementById('integration-code').value;
                    navigator.clipboard.writeText(code);
                    alert('Integration code copied to clipboard!');
                });
                
                document.getElementById('copy-api-docs').addEventListener('click', () => {
                    const docs = document.getElementById('api-docs').value;
                    navigator.clipboard.writeText(docs);
                    alert('API docs copied to clipboard!');
                });
                
                // Sync blocks
                document.getElementById('sync-blocks').addEventListener('click', () => {
                    this.syncBlockchain();
                    alert('Blockchain sync initiated');
                });
                
                // Transaction search
                document.getElementById('transaction-search').addEventListener('input', async (e) => {
                    const query = e.target.value.toLowerCase();
                    const transactions = await this.getRecentTransactions(50);
                    const filtered = transactions.filter(tx => 
                        tx.id.toLowerCase().includes(query) ||
                        tx.from.toLowerCase().includes(query) ||
                        tx.to.toLowerCase().includes(query) ||
                        tx.memo.toLowerCase().includes(query)
                    );
                    
                    const container = document.getElementById('transaction-list');
                    
                    if (filtered.length === 0) {
                        container.innerHTML = '<tr><td colspan="6">No matching transactions found</td></tr>';
                        return;
                    }
                    
                    let html = '';
                    
                    filtered.forEach(tx => {
                        const isIncoming = tx.to === this.walletAddress;
                        const type = isIncoming ? 'Incoming' : 'Outgoing';
                        const amountClass = isIncoming ? 'badge-success' : 'badge-error';
                        const otherAddress = isIncoming ? tx.from : tx.to;
                        const amount = this.formatKRC(tx.amount);
                        const status = tx.blockHeight ? 'Confirmed' : 'Pending';
                        const statusClass = tx.blockHeight ? 'badge-success' : 'badge-warning';
                        
                        html += `
                            <tr>
                                <td>${tx.id.substring(0, 8)}...</td>
                                <td><span class="badge ${amountClass}">${type}</span></td>
                                <td>${amount} KRC</td>
                                <td>${otherAddress}</td>
                                <td>${new Date(tx.timestamp).toLocaleString()}</td>
                                <td><span class="badge ${statusClass}">${status}</span></td>
                            </tr>
                        `;
                    });
                    
                    container.innerHTML = html;
                });
            }
            
            showSection(section) {
                // Hide all sections
                document.querySelectorAll('.tab-content').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Show selected section
                document.getElementById(`${section}-section`).classList.add('active');
                
                // Update active nav link
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                
                document.querySelector(`.nav-link[data-section="${section}"]`).classList.add('active');
                
                // Load section-specific data
                if (section === 'transactions') {
                    this.updateTransactionHistory();
                } else if (section === 'network') {
                    this.updateValidatorStatus();
                } else if (section === 'admin') {
                    this.updateAdminUI();
                }
            }
            
            showTab(tabName) {
                // Hide all tab contents
                document.querySelectorAll('[data-tab-content]').forEach(el => {
                    el.classList.remove('active');
                });
                
                // Deactivate all tabs
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                // Show selected tab content
                document.querySelector(`[data-tab-content="${tabName}"]`).classList.add('active');
                
                // Activate selected tab
                document.querySelector(`.tab[data-tab="${tabName}"]`).classList.add('active');
            }
        }
        
        // Initialize the blockchain when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            const kiiraCoin = new KiiraCoinBlockchain();
            
            // Expose to window for debugging
            window.kiiraCoin = kiiraCoin;
            
            // Setup event handlers after a short delay to ensure UI is ready
            setTimeout(() => {
                kiiraCoin.setupEventHandlers();
            }, 1000);
            
            // Check for referral code in URL
            const urlParams = new URLSearchParams(window.location.search);
            const referralCode = urlParams.get('ref');
            
            if (referralCode && !localStorage.getItem('krc-wallet')) {
                // New user with referral code
                const initialBalance = kiiraCoin.totalSupply * kiiraCoin.initialUserReward;
                
                // Add initial balance transaction
                await kiiraCoin.addTransaction({
                    from: 'genesis',
                    to: kiiraCoin.walletAddress,
                    amount: initialBalance,
                    memo: `New user reward ${referralCode}`,
                    timestamp: Date.now()
                });
            } else if (!localStorage.getItem('krc-wallet')) {
                // New user without referral code
                const initialBalance = kiiraCoin.totalSupply * kiiraCoin.initialUserReward;
                
                // Add initial balance transaction
                await kiiraCoin.addTransaction({
                    from: 'genesis',
                    to: kiiraCoin.walletAddress,
                    amount: initialBalance,
                    memo: 'New user reward',
                    timestamp: Date.now()
                });
            }
        });
    </script>
</body>
</html>
