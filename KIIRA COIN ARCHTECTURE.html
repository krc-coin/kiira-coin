<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kiira Coin Blockchain</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #166088;
            --accent: #4fc3f7;
            --background: #f5f7fa;
            --text: #333;
            --card: #fff;
            --error: #e53935;
            --success: #43a047;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: var(--background);
            color: var(--text);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary);
            color: white;
            padding: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .logo img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }
        
        nav ul {
            display: flex;
            list-style: none;
            gap: 20px;
        }
        
        nav a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: opacity 0.3s;
        }
        
        nav a:hover {
            opacity: 0.8;
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .sidebar {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .sidebar-menu {
            list-style: none;
        }
        
        .sidebar-menu li {
            margin-bottom: 15px;
        }
        
        .sidebar-menu a {
            color: var(--text);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        
        .sidebar-menu a:hover, .sidebar-menu a.active {
            background-color: rgba(74, 111, 165, 0.1);
            color: var(--primary);
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .card {
            background-color: var(--card);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .card-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--primary);
        }
        
        .wallet-info {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .wallet-balance {
            font-size: 2rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .wallet-address {
            background-color: rgba(0,0,0,0.05);
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            word-break: break-all;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary);
            color: white;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background-color: var(--secondary);
        }
        
        .btn-secondary {
            background-color: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-secondary:hover {
            background-color: rgba(74, 111, 165, 0.1);
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        input, textarea, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }
        
        .transaction-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .transaction-item {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            border-radius: 4px;
            background-color: rgba(0,0,0,0.02);
            transition: background-color 0.3s;
        }
        
        .transaction-item:hover {
            background-color: rgba(0,0,0,0.05);
        }
        
        .transaction-details {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .transaction-amount {
            font-weight: 600;
        }
        
        .positive {
            color: var(--success);
        }
        
        .negative {
            color: var(--error);
        }
        
        .admin-panel {
            display: none;
        }
        
        .admin-only {
            display: none;
        }
        
        .super-admin .admin-only {
            display: block;
        }
        
        .super-admin .admin-panel {
            display: block;
        }
        
        .peers-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .peer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: rgba(0,0,0,0.02);
            border-radius: 4px;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success);
        }
        
        .status-indicator.offline {
            background-color: var(--error);
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .stat-card {
            background-color: var(--card);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
        }
        
        .captcha-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background-color: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        
        .captcha-image {
            background-color: #f0f0f0;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            letter-spacing: 3px;
            user-select: none;
        }
        
        .referral-link {
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: rgba(0,0,0,0.02);
            padding: 10px;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        .copy-btn {
            background-color: var(--primary);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            background-color: var(--success);
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        .notification.error {
            background-color: var(--error);
        }
        
        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                order: 2;
            }
            
            .main-content {
                order: 1;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container header-content">
            <div class="logo">
                <img id="coin-icon" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1MTIgNTEyIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMjU2IDhDMTE5IDggOCAxMTkgOCAyNTZzMTExIDI0OCAyNDggMjQ4IDI0OC0xMTEgMjQ4LTI0OFMzOTMgOCAyNTYgOHptMCA0NDhjLTExMC41IDAtMjAwLTg5LjUtMjAwLTIwMFMxNDUuNSA1NiAyNTYgNTZzMjAwIDg5LjUgMjAwIDIwMC04OS41IDIwMC0yMDAgMjAwem0xMDEuOC0yNjEuN0wtMjE2LjQgMzYzLjhsLTE3LjctMTcuNyAzNTQuNC0zNTQuNCAxNy43IDE3LjctMzU0LjQgMzU0LjR6Ii8+PC9zdmc+" alt="Kiira Coin Icon"/>
                <h1>Kiira Coin</h1>
            </div>
            <nav>
                <ul>
                    <li><a href="#" class="nav-link" data-page="dashboard">Dashboard</a></li>
                    <li><a href="#" class="nav-link" data-page="transactions">Transactions</a></li>
                    <li><a href="#" class="nav-link" data-page="staking">Staking</a></li>
                    <li><a href="#" class="nav-link admin-only" data-page="admin">Admin</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <div class="loading-screen" id="loadingScreen">
        <div class="spinner"></div>
        <h2>Initializing Kiira Coin Blockchain...</h2>
        <p id="loadingStatus">Connecting to network...</p>
    </div>

    <div class="container" id="appContent" style="display: none;">
        <div class="dashboard">
            <div class="sidebar">
                <div class="wallet-info">
                    <div>
                        <div class="stat-label">Your Balance</div>
                        <div class="wallet-balance" id="walletBalance">0 KRC</div>
                    </div>
                    <div>
                        <div class="stat-label">Your Address</div>
                        <div class="wallet-address" id="walletAddress">Loading...</div>
                    </div>
                    <button class="btn" id="copyAddressBtn">Copy Address</button>
                    <button class="btn btn-secondary" id="sendFundsBtn">Send KRC</button>
                </div>
                
                <ul class="sidebar-menu">
                    <li><a href="#" class="nav-link active" data-page="dashboard"><i class="icon">📊</i> Dashboard</a></li>
                    <li><a href="#" class="nav-link" data-page="transactions"><i class="icon">📝</i> Transactions</a></li>
                    <li><a href="#" class="nav-link" data-page="staking"><i class="icon">💰</i> Staking</a></li>
                    <li><a href="#" class="nav-link" data-page="referrals"><i class="icon">👥</i> Referrals</a></li>
                    <li><a href="#" class="nav-link" data-page="captcha"><i class="icon">🔍</i> Earn KRC</a></li>
                    <li><a href="#" class="nav-link admin-only" data-page="admin"><i class="icon">⚙️</i> Admin Panel</a></li>
                </ul>
                
                <div class="referral-link">
                    <span id="referralCode">Loading...</span>
                    <button class="copy-btn" id="copyReferralBtn">Copy</button>
                </div>
                
                <div class="peers-info" style="margin-top: 20px;">
                    <div class="stat-label">Network Status</div>
                    <div id="networkStatus">Connecting...</div>
                    <div class="stat-label">Peers Connected</div>
                    <div id="peersCount">0</div>
                </div>
            </div>
            
            <div class="main-content">
                <!-- Dashboard Page -->
                <div class="page-content active" id="dashboard-page">
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value" id="totalSupply">10,000,000</div>
                            <div class="stat-label">Total Supply (KRC)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="circulatingSupply">0</div>
                            <div class="stat-label">Circulating Supply</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="blockHeight">0</div>
                            <div class="stat-label">Block Height</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="activeNodes">0</div>
                            <div class="stat-label">Active Nodes</div>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Recent Transactions</h2>
                            <a href="#" class="nav-link" data-page="transactions">View All</a>
                        </div>
                        <div class="transaction-list" id="recentTransactions">
                            <div class="transaction-item">
                                <div class="transaction-details">
                                    <div>Loading transactions...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card admin-only">
                        <div class="card-header">
                            <h2 class="card-title">Admin Quick Actions</h2>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn" id="updateSettingsBtn">Update Settings</button>
                            <button class="btn btn-secondary" id="viewPeersBtn">View Peers</button>
                            <button class="btn btn-secondary" id="broadcastMessageBtn">Broadcast Message</button>
                        </div>
                    </div>
                </div>
                
                <!-- Transactions Page -->
                <div class="page-content" id="transactions-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Transaction History</h2>
                            <button class="btn" id="refreshTransactionsBtn">Refresh</button>
                        </div>
                        <div class="transaction-list" id="allTransactions">
                            <div class="transaction-item">
                                <div class="transaction-details">
                                    <div>Loading transactions...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Staking Page -->
                <div class="page-content" id="staking-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Stake Your KRC</h2>
                        </div>
                        <div class="form-group">
                            <label for="stakeAmount">Amount to Stake</label>
                            <input type="number" id="stakeAmount" placeholder="Enter amount to stake">
                        </div>
                        <button class="btn" id="stakeBtn">Stake KRC</button>
                        <button class="btn btn-secondary" id="unstakeBtn">Unstake KRC</button>
                        
                        <div style="margin-top: 20px;">
                            <h3>Your Staking Info</h3>
                            <p>Staked Amount: <span id="stakedAmount">0</span> KRC</p>
                            <p>Estimated Rewards: <span id="stakingRewards">0</span> KRC</p>
                        </div>
                    </div>
                    
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Validator Nodes</h2>
                        </div>
                        <div class="peers-list" id="validatorNodes">
                            <div class="peer-item">
                                <div>Loading validators...</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Referrals Page -->
                <div class="page-content" id="referrals-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Your Referrals</h2>
                        </div>
                        <div>
                            <p>Share your referral link to earn 10% of your referrals' rewards:</p>
                            <div class="referral-link">
                                <span id="fullReferralLink">Loading...</span>
                                <button class="copy-btn" id="copyFullReferralBtn">Copy</button>
                            </div>
                            
                            <h3 style="margin-top: 20px;">Your Referral Stats</h3>
                            <p>Total Referrals: <span id="totalReferrals">0</span></p>
                            <p>Earned from Referrals: <span id="referralEarnings">0</span> KRC</p>
                            
                            <h3 style="margin-top: 20px;">Referral History</h3>
                            <div class="transaction-list" id="referralHistory">
                                <div class="transaction-item">
                                    <div class="transaction-details">
                                        <div>Loading referral history...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Earn KRC Page -->
                <div class="page-content" id="captcha-page">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Earn KRC</h2>
                        </div>
                        <div class="captcha-container">
                            <h3>Solve CAPTCHA to Earn KRC</h3>
                            <div class="captcha-image" id="captchaText">KRC123</div>
                            <input type="text" id="captchaInput" placeholder="Enter the text above">
                            <button class="btn" id="submitCaptchaBtn">Submit</button>
                            <p>You'll earn <span id="captchaReward">0.1</span> KRC for each solved CAPTCHA</p>
                        </div>
                        
                        <div style="margin-top: 20px;">
                            <h3>Online Presence Rewards</h3>
                            <p>Stay online to earn passive KRC rewards. Current rate: <span id="onlineRewardRate">0.01</span> KRC per minute.</p>
                            <p>Time online this session: <span id="onlineTime">0</span> minutes</p>
                            <p>Earned this session: <span id="onlineEarnings">0</span> KRC</p>
                        </div>
                    </div>
                </div>
                
                <!-- Admin Page -->
                <div class="page-content admin-panel" id="admin-page">
                    <div class="tab-container">
                        <div class="tab active" data-tab="settings">Settings</div>
                        <div class="tab" data-tab="peers">Peers</div>
                        <div class="tab" data-tab="transactions-admin">All Transactions</div>
                        <div class="tab" data-tab="wallets">Wallets</div>
                        <div class="tab" data-tab="integration">Integration</div>
                    </div>
                    
                    <div class="tab-content active" id="settings-tab">
                        <div class="card">
                            <h2 class="card-title">Blockchain Settings</h2>
                            <form id="blockchainSettingsForm">
                                <div class="form-group">
                                    <label for="blockReward">Block Reward (KRC)</label>
                                    <input type="number" id="blockReward" step="0.00000001" required>
                                </div>
                                <div class="form-group">
                                    <label for="stakeReward">Staking Reward (% per block)</label>
                                    <input type="number" id="stakeReward" step="0.01" required>
                                </div>
                                <div class="form-group">
                                    <label for="referralReward">Referral Reward (%)</label>
                                    <input type="number" id="referralReward" step="0.1" required>
                                </div>
                                <div class="form-group">
                                    <label for="captchaRewardAdmin">CAPTCHA Reward (KRC)</label>
                                    <input type="number" id="captchaRewardAdmin" step="0.00000001" required>
                                </div>
                                <div class="form-group">
                                    <label for="onlineReward">Online Reward (KRC per minute)</label>
                                    <input type="number" id="onlineReward" step="0.00000001" required>
                                </div>
                                <button type="submit" class="btn">Update Settings</button>
                            </form>
                        </div>
                        
                        <div class="card">
                            <h2 class="card-title">Super Admin Controls</h2>
                            <div class="form-group">
                                <label for="coinIconUpload">Upload Coin Icon</label>
                                <input type="file" id="coinIconUpload" accept="image/*">
                            </div>
                            <button class="btn" id="updateCoinIconBtn">Update Icon</button>
                            
                            <div style="margin-top: 20px;">
                                <h3>Blockchain Data</h3>
                                <button class="btn btn-secondary" id="exportBlockchainBtn">Export Blockchain</button>
                                <button class="btn btn-secondary" id="importBlockchainBtn">Import Blockchain</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tab-content" id="peers-tab">
                        <div class="card">
                            <h2 class="card-title">Connected Peers</h2>
                            <div class="peers-list" id="adminPeersList">
                                <div class="peer-item">
                                    <div>Loading peers...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tab-content" id="transactions-admin-tab">
                        <div class="card">
                            <h2 class="card-title">All Blockchain Transactions</h2>
                            <div class="transaction-list" id="adminTransactionsList">
                                <div class="transaction-item">
                                    <div class="transaction-details">
                                        <div>Loading transactions...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tab-content" id="wallets-tab">
                        <div class="card">
                            <h2 class="card-title">Wallet Balances</h2>
                            <div style="margin-bottom: 15px;">
                                <input type="text" id="walletSearch" placeholder="Search wallets...">
                            </div>
                            <div class="transaction-list" id="walletsList">
                                <div class="peer-item">
                                    <div>Loading wallets...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="tab-content" id="integration-tab">
                        <div class="card">
                            <h2 class="card-title">Exchange Integration</h2>
                            <form id="exchangeIntegrationForm">
                                <div class="form-group">
                                    <label for="coinGeckoApiKey">CoinGecko API Key</label>
                                    <input type="password" id="coinGeckoApiKey" placeholder="Enter API key">
                                </div>
                                <div class="form-group">
                                    <label for="coinMarketCapApiKey">CoinMarketCap API Key</label>
                                    <input type="password" id="coinMarketCapApiKey" placeholder="Enter API key">
                                </div>
                                <div class="form-group">
                                    <label for="cryptoCompareApiKey">CryptoCompare API Key</label>
                                    <input type="password" id="cryptoCompareApiKey" placeholder="Enter API key">
                                </div>
                                <button type="submit" class="btn">Save API Keys</button>
                            </form>
                            
                            <div style="margin-top: 20px;">
                                <h3>Listing Information</h3>
                                <div class="form-group">
                                    <label for="coinDescription">Coin Description</label>
                                    <textarea id="coinDescription" rows="4"></textarea>
                                </div>
                                <div class="form-group">
                                    <label for="coinWebsite">Website URL</label>
                                    <input type="url" id="coinWebsite">
                                </div>
                                <div class="form-group">
                                    <label for="coinExplorer">Block Explorer URL</label>
                                    <input type="url" id="coinExplorer">
                                </div>
                                <button class="btn" id="submitToListingBtn">Submit to Listing Sites</button>
                            </div>
                            
                            <div style="margin-top: 20px;">
                                <h3>Payment Integration</h3>
                                <p>Use this code to integrate KRC payments on your website:</p>
                                <pre id="paymentIntegrationCode" style="background-color: #f5f5f5; padding: 10px; border-radius: 4px; overflow-x: auto;">Loading integration code...</pre>
                                <button class="btn" id="copyIntegrationCodeBtn">Copy Code</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Send Funds Modal -->
                <div class="modal" id="sendFundsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
                    <div class="card" style="max-width: 500px; width: 90%;">
                        <div class="card-header">
                            <h2 class="card-title">Send KRC</h2>
                            <button class="btn btn-secondary" id="closeSendModalBtn">✕</button>
                        </div>
                        <form id="sendFundsForm">
                            <div class="form-group">
                                <label for="recipientAddress">Recipient Address</label>
                                <input type="text" id="recipientAddress" placeholder="Enter KRC address (starts with KRC)" required>
                            </div>
                            <div class="form-group">
                                <label for="sendAmount">Amount (KRC)</label>
                                <input type="number" id="sendAmount" step="0.00000001" placeholder="Enter amount" required>
                            </div>
                            <div class="form-group">
                                <label for="transactionMemo">Memo (Optional)</label>
                                <input type="text" id="transactionMemo" placeholder="Enter memo">
                            </div>
                            <button type="submit" class="btn">Send Transaction</button>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
        // Kiira Coin Blockchain Implementation
        class KiiraCoinBlockchain {
            constructor() {
                this.dbName = 'KiiraCoinBlockchain';
                this.dbVersion = 1;
                this.db = null;
                this.peers = [];
                this.peer = null;
                this.wallet = null;
                this.chain = [];
                this.pendingTransactions = [];
                this.settings = {
                    blockReward: 10,
                    stakeReward: 0.1,
                    referralReward: 10,
                    captchaReward: 0.1,
                    onlineReward: 0.01,
                    totalSupply: 10000000,
                    decimals: 8,
                    genesisAllocation: 0.5, // 50% to super admin
                    userAllocation: 0.1, // 10% to new users
                    superAdmin: null,
                    coinIcon: null,
                    coinDescription: "Kiira Coin is a lightweight blockchain with Proof of Stake consensus, designed for microtransactions and user rewards.",
                    coinWebsite: "https://kiira-coin.example.com",
                    coinExplorer: "https://explorer.kiira-coin.example.com"
                };
                
                this.isSuperAdmin = false;
                this.onlineTimer = null;
                this.onlineSeconds = 0;
                this.referralCode = null;
                this.stakingBalance = 0;
                this.lastStakeUpdate = 0;
                this.initialized = false;
                
                this.init();
            }
            
            async init() {
                try {
                    updateLoadingStatus("Opening database...");
                    await this.openDatabase();
                    
                    updateLoadingStatus("Loading blockchain data...");
                    await this.loadBlockchain();
                    
                    updateLoadingStatus("Initializing wallet...");
                    await this.initWallet();
                    
                    updateLoadingStatus("Connecting to network...");
                    await this.initNetwork();
                    
                    updateLoadingStatus("Syncing with network...");
                    await this.syncWithNetwork();
                    
                    updateLoadingStatus("Starting services...");
                    await this.startServices();
                    
                    this.initialized = true;
                    showApp();
                } catch (error) {
                    console.error("Initialization error:", error);
                    updateLoadingStatus(`Error: ${error.message}`);
                    
                    // Try to recover after 5 seconds
                    setTimeout(() => {
                        updateLoadingStatus("Retrying initialization...");
                        this.init();
                    }, 5000);
                }
            }
            
            async openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create object stores
                        if (!db.objectStoreNames.contains('blocks')) {
                            db.createObjectStore('blocks', { keyPath: 'height' });
                        }
                        
                        if (!db.objectStoreNames.contains('transactions')) {
                            const txStore = db.createObjectStore('transactions', { keyPath: 'id' });
                            txStore.createIndex('from', 'from', { unique: false });
                            txStore.createIndex('to', 'to', { unique: false });
                            txStore.createIndex('blockHeight', 'blockHeight', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('wallets')) {
                            const walletStore = db.createObjectStore('wallets', { keyPath: 'address' });
                            walletStore.createIndex('publicKey', 'publicKey', { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('peers')) {
                            db.createObjectStore('peers', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                        
                        if (!db.objectStoreNames.contains('referrals')) {
                            const refStore = db.createObjectStore('referrals', { keyPath: 'id' });
                            refStore.createIndex('referrer', 'referrer', { unique: false });
                            refStore.createIndex('referred', 'referred', { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('staking')) {
                            db.createObjectStore('staking', { keyPath: 'address' });
                        }
                    };
                    
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };
                    
                    request.onerror = (event) => {
                        reject(new Error("Failed to open database"));
                    };
                });
            }
            
            async loadBlockchain() {
                // Load settings first
                const settings = await this.getAllSettings();
                if (settings) {
                    this.settings = { ...this.settings, ...settings };
                }
                
                // Load chain
                const lastBlock = await this.getLastBlock();
                if (!lastBlock) {
                    // Genesis block doesn't exist, create it
                    await this.createGenesisBlock();
                } else {
                    // Load the chain from database
                    const blocks = await this.getAllBlocks();
                    this.chain = blocks.sort((a, b) => a.height - b.height);
                }
                
                // Load pending transactions
                this.pendingTransactions = await this.getPendingTransactions();
            }
            
            async createGenesisBlock() {
                const genesisBlock = {
                    height: 0,
                    timestamp: Date.now(),
                    transactions: [],
                    previousHash: '0',
                    hash: this.calculateBlockHash(0, '0', [], Date.now()),
                    validator: null,
                    signature: null
                };
                
                await this.addBlock(genesisBlock);
                this.chain = [genesisBlock];
                
                // If this is the first run, set the first user as super admin
                if (!this.settings.superAdmin) {
                    this.isSuperAdmin = true;
                    document.body.classList.add('super-admin');
                }
            }
            
            async initWallet() {
                // Check if wallet exists in database
                const wallets = await this.getAllWallets();
                
                if (wallets.length > 0) {
                    // Use the first wallet (we're only using one wallet per client for simplicity)
                    this.wallet = wallets[0];
                    
                    // Check if this is the super admin
                    if (this.wallet.address === this.settings.superAdmin) {
                        this.isSuperAdmin = true;
                        document.body.classList.add('super-admin');
                    }
                } else {
                    // Create new wallet
                    this.wallet = await this.createWallet();
                    
                    // If this is the first wallet, set as super admin and give genesis allocation
                    if (!this.settings.superAdmin) {
                        this.settings.superAdmin = this.wallet.address;
                        this.isSuperAdmin = true;
                        document.body.classList.add('super-admin');
                        
                        // Add genesis allocation transaction
                        const genesisAmount = this.settings.totalSupply * this.settings.genesisAllocation;
                        await this.createTransaction(
                            null, // From null for genesis transaction
                            this.wallet.address,
                            genesisAmount,
                            'Genesis allocation'
                        );
                        
                        // Save settings
                        await this.saveSettings();
                    } else {
                        // Give new user allocation
                        const userAmount = this.settings.totalSupply * this.settings.userAllocation;
                        await this.createTransaction(
                            null, // From null for new user allocation
                            this.wallet.address,
                            userAmount,
                            'New user allocation'
                        );
                    }
                }
                
                // Generate referral code
                this.referralCode = this.generateReferralCode(this.wallet.address);
                
                // Load staking balance
                const stakingInfo = await this.getStakingInfo(this.wallet.address);
                if (stakingInfo) {
                    this.stakingBalance = stakingInfo.amount;
                    this.lastStakeUpdate = stakingInfo.lastUpdate;
                }
                
                // Update UI
                updateWalletInfo(this.wallet.address, await this.getBalance(this.wallet.address));
            }
            
            async createWallet() {
                // In a real implementation, we would generate a proper key pair
                // For this demo, we'll simulate it
                const keyPair = {
                    publicKey: 'KRC' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15),
                    privateKey: 'priv' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
                };
                
                const wallet = {
                    address: keyPair.publicKey,
                    publicKey: keyPair.publicKey,
                    // In a real app, private key should NEVER be stored in IndexedDB
                    // This is just for demo purposes
                    privateKey: keyPair.privateKey
                };
                
                await this.saveWallet(wallet);
                return wallet;
            }
            
            async initNetwork() {
                // In a real implementation, we would use WebRTC or WebSockets for P2P networking
                // For this demo, we'll simulate it with a central signaling server
                
                // Load known peers from database
                this.peers = await this.getAllPeers();
                
                if (this.peers.length === 0 && !this.isSuperAdmin) {
                    // If no peers and not super admin, we can't connect
                    throw new Error("No peers available to connect to");
                }
                
                // Simulate connecting to peers
                this.peer = {
                    id: 'local-peer',
                    send: (data) => {
                        // In a real implementation, this would send data to connected peers
                        console.log("Sending data to peers:", data);
                        
                        // Simulate receiving data back after a delay
                        setTimeout(() => {
                            this.handleNetworkMessage(data);
                        }, 500);
                    }
                };
                
                // If we have peers, connect to them
                if (this.peers.length > 0) {
                    // Simulate connection
                    updateNetworkStatus(`Connected to ${this.peers.length} peers`);
                } else if (this.isSuperAdmin) {
                    // Super admin is the first node
                    updateNetworkStatus("Running as genesis node");
                }
            }
            
            async syncWithNetwork() {
                // Get the latest block from peers
                const latestBlock = await this.getLatestBlockFromNetwork();
                
                if (latestBlock && latestBlock.height > this.getBlockHeight()) {
                    // We're behind, sync the chain
                    await this.downloadBlocks(this.getBlockHeight() + 1, latestBlock.height);
                }
                
                // Broadcast our presence
                this.broadcastPresence();
            }
            
            async startServices() {
                // Start block production if we're a validator
                if (await this.isValidator(this.wallet.address)) {
                    this.startBlockProduction();
                }
                
                // Start online presence tracking
                this.startOnlineTracking();
                
                // Start periodic sync with network
                setInterval(() => this.syncWithNetwork(), 30000);
                
                // Update UI periodically
                setInterval(() => this.updateUI(), 5000);
            }
            
            startOnlineTracking() {
                // Track online time
                this.onlineSeconds = 0;
                this.onlineTimer = setInterval(async () => {
                    this.onlineSeconds++;
                    
                    // Every minute, reward online presence
                    if (this.onlineSeconds % 60 === 0) {
                        const minutesOnline = this.onlineSeconds / 60;
                        const reward = this.settings.onlineReward * minutesOnline;
                        
                        // Reset counter after rewarding
                        this.onlineSeconds = 0;
                        
                        await this.createTransaction(
                            null, // From null for rewards
                            this.wallet.address,
                            reward,
                            'Online presence reward'
                        );
                        
                        showNotification(`You earned ${reward.toFixed(8)} KRC for being online`);
                    }
                    
                    // Update UI
                    updateOnlineTime(this.onlineSeconds);
                }, 1000);
            }
            
            startBlockProduction() {
                // In a real implementation, this would create blocks at intervals
                // based on the consensus mechanism
                console.log("Starting block production as validator");
            }
            
            async downloadBlocks(startHeight, endHeight) {
                // Simulate downloading blocks from peers
                for (let height = startHeight; height <= endHeight; height++) {
                    const block = await this.getBlockFromNetwork(height);
                    if (block) {
                        await this.addBlock(block);
                    }
                }
            }
            
            // Database operations
            async getAllBlocks() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting blocks"));
                });
            }
            
            async getBlock(height) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.get(height);
                    
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(new Error("Error getting block"));
                });
            }
            
            async getLastBlock() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks'], 'readonly');
                    const store = transaction.objectStore('blocks');
                    const request = store.openCursor(null, 'prev');
                    
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        resolve(cursor ? cursor.value : null);
                    };
                    
                    request.onerror = () => reject(new Error("Error getting last block"));
                });
            }
            
            async addBlock(block) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['blocks', 'transactions'], 'readwrite');
                    const blockStore = transaction.objectStore('blocks');
                    const txStore = transaction.objectStore('transactions');
                    
                    // Add block
                    blockStore.put(block);
                    
                    // Update transactions to mark them as confirmed
                    block.transactions.forEach(tx => {
                        if (tx.id) { // Skip coinbase transactions
                            const updateRequest = txStore.get(tx.id);
                            updateRequest.onsuccess = () => {
                                const existingTx = updateRequest.result;
                                if (existingTx) {
                                    existingTx.blockHeight = block.height;
                                    txStore.put(existingTx);
                                }
                            };
                        }
                    });
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(new Error("Error adding block"));
                });
            }
            
            async getAllTransactions() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting transactions"));
                });
            }
            
            async getPendingTransactions() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const index = store.index('blockHeight');
                    const request = index.getAll(IDBKeyRange.only(null));
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting pending transactions"));
                });
            }
            
            async addTransaction(transaction) {
                return new Promise((resolve, reject) => {
                    const transactionDB = this.db.transaction(['transactions'], 'readwrite');
                    const store = transactionDB.objectStore('transactions');
                    const request = store.put(transaction);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error adding transaction"));
                });
            }
            
            async getAllWallets() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readonly');
                    const store = transaction.objectStore('wallets');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting wallets"));
                });
            }
            
            async getWallet(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readonly');
                    const store = transaction.objectStore('wallets');
                    const request = store.get(address);
                    
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(new Error("Error getting wallet"));
                });
            }
            
            async saveWallet(wallet) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['wallets'], 'readwrite');
                    const store = transaction.objectStore('wallets');
                    const request = store.put(wallet);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error saving wallet"));
                });
            }
            
            async getAllPeers() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readonly');
                    const store = transaction.objectStore('peers');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting peers"));
                });
            }
            
            async addPeer(peer) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readwrite');
                    const store = transaction.objectStore('peers');
                    const request = store.put(peer);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error adding peer"));
                });
            }
            
            async removePeer(peerId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['peers'], 'readwrite');
                    const store = transaction.objectStore('peers');
                    const request = store.delete(peerId);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error removing peer"));
                });
            }
            
            async getAllSettings() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const request = store.getAll();
                    
                    request.onsuccess = () => {
                        const settings = {};
                        (request.result || []).forEach(item => {
                            settings[item.key] = item.value;
                        });
                        resolve(settings);
                    };
                    
                    request.onerror = () => reject(new Error("Error getting settings"));
                });
            }
            
            async saveSettings() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    
                    // Clear existing settings
                    store.clear();
                    
                    // Save all settings
                    Object.keys(this.settings).forEach(key => {
                        if (key !== 'dbName' && key !== 'dbVersion' && key !== 'db') {
                            store.put({ key, value: this.settings[key] });
                        }
                    });
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(new Error("Error saving settings"));
                });
            }
            
            async getStakingInfo(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['staking'], 'readonly');
                    const store = transaction.objectStore('staking');
                    const request = store.get(address);
                    
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(new Error("Error getting staking info"));
                });
            }
            
            async saveStakingInfo(info) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['staking'], 'readwrite');
                    const store = transaction.objectStore('staking');
                    const request = store.put(info);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error saving staking info"));
                });
            }
            
            async getReferralsByReferrer(referrer) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['referrals'], 'readonly');
                    const store = transaction.objectStore('referrals');
                    const index = store.index('referrer');
                    const request = index.getAll(IDBKeyRange.only(referrer));
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting referrals"));
                });
            }
            
            async addReferral(referral) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['referrals'], 'readwrite');
                    const store = transaction.objectStore('referrals');
                    const request = store.put(referral);
                    
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error("Error adding referral"));
                });
            }
            
            // Blockchain operations
            getBlockHeight() {
                return this.chain.length > 0 ? this.chain[this.chain.length - 1].height : -1;
            }
            
            calculateBlockHash(height, previousHash, transactions, timestamp) {
                // In a real implementation, this would use proper cryptographic hashing
                const data = `${height}${previousHash}${JSON.stringify(transactions)}${timestamp}`;
                return 'hash_' + btoa(data).substring(0, 64);
            }
            
            async createBlock(transactions, validator) {
                const lastBlock = this.chain[this.chain.length - 1];
                const height = lastBlock.height + 1;
                const timestamp = Date.now();
                const previousHash = lastBlock.hash;
                const hash = this.calculateBlockHash(height, previousHash, transactions, timestamp);
                
                // Add block reward transaction
                const blockRewardTx = {
                    from: null,
                    to: validator,
                    amount: this.settings.blockReward,
                    memo: 'Block reward',
                    timestamp: timestamp
                };
                
                transactions.unshift(blockRewardTx);
                
                const block = {
                    height,
                    timestamp,
                    transactions,
                    previousHash,
                    hash,
                    validator,
                    signature: this.signBlock(validator, hash)
                };
                
                await this.addBlock(block);
                this.chain.push(block);
                
                // Clear pending transactions that were included in the block
                this.pendingTransactions = this.pendingTransactions.filter(tx => 
                    !transactions.some(btx => btx.id === tx.id)
                );
                
                return block;
            }
            
            async createTransaction(from, to, amount, memo = '') {
                // Validate transaction
                if (from !== null) {
                    const balance = await this.getBalance(from);
                    if (balance < amount) {
                        throw new Error("Insufficient balance");
                    }
                }
                
                if (to === null) {
                    throw new Error("Invalid recipient");
                }
                
                if (amount <= 0) {
                    throw new Error("Amount must be positive");
                }
                
                const transaction = {
                    id: 'tx_' + Math.random().toString(36).substring(2, 15),
                    from,
                    to,
                    amount,
                    memo,
                    timestamp: Date.now(),
                    blockHeight: null, // Will be set when included in a block
                    signature: from ? this.signTransaction(from, to, amount, memo) : null
                };
                
                await this.addTransaction(transaction);
                this.pendingTransactions.push(transaction);
                
                // Broadcast transaction to network
                this.broadcastTransaction(transaction);
                
                return transaction;
            }
            
            async getBalance(address) {
                // Get all transactions where address is the recipient
                const received = await this.getReceivedTransactions(address);
                const receivedAmount = received.reduce((sum, tx) => sum + tx.amount, 0);
                
                // Get all transactions where address is the sender
                const sent = await this.getSentTransactions(address);
                const sentAmount = sent.reduce((sum, tx) => sum + tx.amount, 0);
                
                return receivedAmount - sentAmount;
            }
            
            async getReceivedTransactions(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const index = store.index('to');
                    const request = index.getAll(IDBKeyRange.only(address));
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting received transactions"));
                });
            }
            
            async getSentTransactions(address) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['transactions'], 'readonly');
                    const store = transaction.objectStore('transactions');
                    const index = store.index('from');
                    const request = index.getAll(IDBKeyRange.only(address));
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting sent transactions"));
                });
            }
            
            async getTransactionsByAddress(address) {
                const received = await this.getReceivedTransactions(address);
                const sent = await this.getSentTransactions(address);
                
                return [...received, ...sent].sort((a, b) => b.timestamp - a.timestamp);
            }
            
            async isValidator(address) {
                // In PoS, validators are those with staked coins
                const stakingInfo = await this.getStakingInfo(address);
                return stakingInfo && stakingInfo.amount > 0;
            }
            
            async stake(amount) {
                if (amount <= 0) {
                    throw new Error("Amount must be positive");
                }
                
                const balance = await this.getBalance(this.wallet.address);
                if (balance < amount) {
                    throw new Error("Insufficient balance");
                }
                
                // Create staking transaction (this is a special transaction that locks funds)
                const stakingInfo = await this.getStakingInfo(this.wallet.address);
                const newAmount = (stakingInfo?.amount || 0) + amount;
                
                await this.saveStakingInfo({
                    address: this.wallet.address,
                    amount: newAmount,
                    lastUpdate: Date.now()
                });
                
                this.stakingBalance = newAmount;
                this.lastStakeUpdate = Date.now();
                
                // Deduct from available balance (in a real implementation, this would be more sophisticated)
                await this.createTransaction(
                    this.wallet.address,
                    null, // Special address for staking
                    amount,
                    'Staking'
                );
                
                return newAmount;
            }
            
            async unstake(amount) {
                if (amount <= 0) {
                    throw new Error("Amount must be positive");
                }
                
                const stakingInfo = await this.getStakingInfo(this.wallet.address);
                if (!stakingInfo || stakingInfo.amount < amount) {
                    throw new Error("Insufficient staked amount");
                }
                
                // Calculate rewards first
                const rewards = await this.calculateStakingRewards();
                if (rewards > 0) {
                    await this.claimStakingRewards();
                }
                
                // Update staking balance
                const newAmount = stakingInfo.amount - amount;
                
                if (newAmount > 0) {
                    await this.saveStakingInfo({
                        address: this.wallet.address,
                        amount: newAmount,
                        lastUpdate: Date.now()
                    });
                } else {
                    // Remove staking info if amount is zero
                    const transaction = this.db.transaction(['staking'], 'readwrite');
                    const store = transaction.objectStore('staking');
                    store.delete(this.wallet.address);
                }
                
                this.stakingBalance = newAmount;
                this.lastStakeUpdate = Date.now();
                
                // Add back to available balance
                await this.createTransaction(
                    null, // Special address for staking
                    this.wallet.address,
                    amount,
                    'Unstaking'
                );
                
                return newAmount;
            }
            
            async calculateStakingRewards() {
                if (!this.lastStakeUpdate || this.stakingBalance <= 0) {
                    return 0;
                }
                
                const timeStaked = Date.now() - this.lastStakeUpdate;
                const daysStaked = timeStaked / (1000 * 60 * 60 * 24);
                
                // Calculate rewards based on annual percentage rate
                const apr = this.settings.stakeReward * 365; // Convert daily to annual
                const rewards = this.stakingBalance * (apr / 100) * (daysStaked / 365);
                
                return rewards;
            }
            
            async claimStakingRewards() {
                const rewards = await this.calculateStakingRewards();
                if (rewards <= 0) {
                    return 0;
                }
                
                await this.createTransaction(
                    null, // From null for rewards
                    this.wallet.address,
                    rewards,
                    'Staking rewards'
                );
                
                // Update last stake update time
                this.lastStakeUpdate = Date.now();
                await this.saveStakingInfo({
                    address: this.wallet.address,
                    amount: this.stakingBalance,
                    lastUpdate: this.lastStakeUpdate
                });
                
                return rewards;
            }
            
            async solveCaptcha(solution) {
                // In a real implementation, this would validate the CAPTCHA solution
                // For demo purposes, we'll just reward for any solution
                
                await this.createTransaction(
                    null, // From null for rewards
                    this.wallet.address,
                    this.settings.captchaReward,
                    'CAPTCHA reward'
                );
                
                // Generate new CAPTCHA
                this.generateNewCaptcha();
                
                return this.settings.captchaReward;
            }
            
            generateNewCaptcha() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789';
                let result = '';
                for (let i = 0; i < 6; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                
                document.getElementById('captchaText').textContent = result;
                return result;
            }
            
            generateReferralCode(address) {
                return 'KRC-' + address.substring(3, 7) + '-' + address.substring(7, 11);
            }
            
            async useReferralCode(code) {
                // Validate code format
                if (!code.match(/^KRC-[A-Z0-9]{4}-[A-Z0-9]{4}$/)) {
                    throw new Error("Invalid referral code format");
                }
                
                // Check if this address already used a referral code
                const existingReferral = await new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['referrals'], 'readonly');
                    const store = transaction.objectStore('referrals');
                    const index = store.index('referred');
                    const request = index.get(this.wallet.address);
                    
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(new Error("Error checking referral"));
                });
                
                if (existingReferral) {
                    throw new Error("You've already used a referral code");
                }
                
                // Find referrer by code
                const referrerAddress = 'KRC' + code.substring(4, 8) + code.substring(9, 13);
                const referrer = await this.getWallet(referrerAddress);
                
                if (!referrer) {
                    throw new Error("Referrer not found");
                }
                
                if (referrer.address === this.wallet.address) {
                    throw new Error("Cannot refer yourself");
                }
                
                // Add referral record
                await this.addReferral({
                    id: 'ref_' + Math.random().toString(36).substring(2, 15),
                    referrer: referrer.address,
                    referred: this.wallet.address,
                    timestamp: Date.now()
                });
                
                // Reward referrer
                const rewardAmount = this.settings.totalSupply * (this.settings.referralReward / 100);
                
                await this.createTransaction(
                    null, // From null for rewards
                    referrer.address,
                    rewardAmount,
                    'Referral reward'
                );
                
                return referrer.address;
            }
            
            // Cryptography functions (simplified for demo)
            signTransaction(from, to, amount, memo) {
                // In a real implementation, this would use proper cryptographic signing
                const data = `${from}${to}${amount}${memo}`;
                return 'sig_' + btoa(data).substring(0, 64);
            }
            
            verifyTransactionSignature(transaction) {
                // In a real implementation, this would verify the cryptographic signature
                if (transaction.from === null) return true; // Genesis/reward transactions
                
                const data = `${transaction.from}${transaction.to}${transaction.amount}${transaction.memo}`;
                const expectedSig = 'sig_' + btoa(data).substring(0, 64);
                return transaction.signature === expectedSig;
            }
            
            signBlock(validator, blockHash) {
                // In a real implementation, this would use proper cryptographic signing
                const data = `${validator}${blockHash}`;
                return 'sig_' + btoa(data).substring(0, 64);
            }
            
            verifyBlockSignature(block) {
                // In a real implementation, this would verify the cryptographic signature
                if (block.height === 0) return true; // Genesis block
                
                const data = `${block.validator}${block.hash}`;
                const expectedSig = 'sig_' + btoa(data).substring(0, 64);
                return block.signature === expectedSig;
            }
            
            // Network operations
            broadcastPresence() {
                if (!this.peer) return;
                
                this.peer.send({
                    type: 'presence',
                    address: this.wallet.address,
                    height: this.getBlockHeight(),
                    timestamp: Date.now()
                });
            }
            
            broadcastTransaction(transaction) {
                if (!this.peer) return;
                
                this.peer.send({
                    type: 'transaction',
                    transaction: transaction
                });
            }
            
            broadcastBlock(block) {
                if (!this.peer) return;
                
                this.peer.send({
                    type: 'block',
                    block: block
                });
            }
            
            handleNetworkMessage(message) {
                if (!message || !message.type) return;
                
                switch (message.type) {
                    case 'presence':
                        this.handlePeerPresence(message);
                        break;
                    case 'transaction':
                        this.handleReceivedTransaction(message.transaction);
                        break;
                    case 'block':
                        this.handleReceivedBlock(message.block);
                        break;
                }
            }
            
            handlePeerPresence(presence) {
                // Update peer list
                const existingPeer = this.peers.find(p => p.address === presence.address);
                if (!existingPeer) {
                    const newPeer = {
                        id: 'peer_' + Math.random().toString(36).substring(2, 15),
                        address: presence.address,
                        height: presence.height,
                        lastSeen: presence.timestamp
                    };
                    
                    this.peers.push(newPeer);
                    this.addPeer(newPeer).catch(console.error);
                    
                    updatePeersList(this.peers);
                } else {
                    existingPeer.height = presence.height;
                    existingPeer.lastSeen = presence.timestamp;
                }
            }
            
            handleReceivedTransaction(transaction) {
                // Check if we already have this transaction
                const existingTx = this.pendingTransactions.find(tx => tx.id === transaction.id);
                if (existingTx) return;
                
                // Validate transaction
                if (!this.verifyTransactionSignature(transaction)) {
                    console.warn("Received invalid transaction:", transaction);
                    return;
                }
                
                // Add to pending transactions
                this.addTransaction(transaction).then(() => {
                    this.pendingTransactions.push(transaction);
                    this.updateTransactionsUI();
                }).catch(console.error);
            }
            
            handleReceivedBlock(block) {
                // Check if we already have this block
                if (block.height <= this.getBlockHeight()) return;
                
                // Validate block
                if (!this.verifyBlock(block)) {
                    console.warn("Received invalid block:", block);
                    return;
                }
                
                // Add block to our chain
                this.addBlock(block).then(() => {
                    this.chain.push(block);
                    this.updateUI();
                }).catch(console.error);
            }
            
            verifyBlock(block) {
                // Verify block structure
                if (!block.height || !block.timestamp || !block.transactions || 
                    !block.previousHash || !block.hash || !block.validator || !block.signature) {
                    return false;
                }
                
                // Verify block hash
                const calculatedHash = this.calculateBlockHash(
                    block.height,
                    block.previousHash,
                    block.transactions,
                    block.timestamp
                );
                
                if (calculatedHash !== block.hash) {
                    return false;
                }
                
                // Verify block signature
                if (!this.verifyBlockSignature(block)) {
                    return false;
                }
                
                // Verify transactions
                for (const tx of block.transactions) {
                    if (!this.verifyTransactionSignature(tx)) {
                        return false;
                    }
                }
                
                return true;
            }
            
            async getLatestBlockFromNetwork() {
                // In a real implementation, this would request the latest block from peers
                // For demo purposes, we'll simulate it
                if (this.peers.length === 0) return null;
                
                // Simulate getting the latest block from a random peer
                const randomPeer = this.peers[Math.floor(Math.random() * this.peers.length)];
                if (randomPeer.height > this.getBlockHeight()) {
                    return {
                        height: randomPeer.height,
                        hash: 'simulated_hash_' + randomPeer.height,
                        previousHash: 'simulated_prev_hash_' + (randomPeer.height - 1),
                        timestamp: Date.now() - (this.getBlockHeight() - randomPeer.height) * 1000,
                        transactions: [],
                        validator: randomPeer.address,
                        signature: 'simulated_signature'
                    };
                }
                
                return null;
            }
            
            async getBlockFromNetwork(height) {
                // In a real implementation, this would request a specific block from peers
                // For demo purposes, we'll simulate it
                return {
                    height,
                    hash: 'simulated_hash_' + height,
                    previousHash: height > 0 ? 'simulated_hash_' + (height - 1) : '0',
                    timestamp: Date.now() - (this.getBlockHeight() - height) * 1000,
                    transactions: [],
                    validator: this.peers.length > 0 ? 
                        this.peers[Math.floor(Math.random() * this.peers.length)].address : 
                        this.wallet.address,
                    signature: 'simulated_signature'
                };
            }
            
            // UI updates
            async updateUI() {
                if (!this.wallet) return;
                
                // Update wallet balance
                const balance = await this.getBalance(this.wallet.address);
                updateWalletInfo(this.wallet.address, balance);
                
                // Update transactions
                this.updateTransactionsUI();
                
                // Update staking info
                this.updateStakingUI();
                
                // Update network info
                updateNetworkInfo(this.getBlockHeight(), this.peers.length);
                
                // Update supply info
                this.updateSupplyInfo();
                
                // Update referral info
                this.updateReferralUI();
            }
            
            async updateTransactionsUI() {
                const transactions = await this.getTransactionsByAddress(this.wallet.address);
                updateRecentTransactions(transactions.slice(0, 5));
                updateAllTransactions(transactions);
                
                if (this.isSuperAdmin) {
                    const allTransactions = await this.getAllTransactions();
                    updateAdminTransactions(allTransactions.slice(0, 50));
                }
            }
            
            async updateStakingUI() {
                const rewards = await this.calculateStakingRewards();
                updateStakingInfo(this.stakingBalance, rewards);
                
                // Update validator nodes list
                const stakers = await new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['staking'], 'readonly');
                    const store = transaction.objectStore('staking');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting stakers"));
                });
                
                updateValidatorNodes(stakers);
            }
            
            async updateSupplyInfo() {
                const wallets = await this.getAllWallets();
                let circulating = 0;
                
                for (const wallet of wallets) {
                    const balance = await this.getBalance(wallet.address);
                    circulating += balance;
                }
                
                updateSupply(this.settings.totalSupply, circulating);
            }
            
            async updateReferralUI() {
                const referrals = await this.getReferralsByReferrer(this.wallet.address);
                updateReferralInfo(referrals);
            }
            
            // Admin functions
            async updateBlockchainSettings(newSettings) {
                this.settings = { ...this.settings, ...newSettings };
                await this.saveSettings();
                return this.settings;
            }
            
            async updateCoinIcon(iconData) {
                this.settings.coinIcon = iconData;
                await this.saveSettings();
                document.getElementById('coin-icon').src = iconData;
                return true;
            }
            
            async exportBlockchain() {
                const blocks = await this.getAllBlocks();
                const transactions = await this.getAllTransactions();
                const wallets = await this.getAllWallets();
                const peers = await this.getAllPeers();
                const settings = await this.getAllSettings();
                const staking = await new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['staking'], 'readonly');
                    const store = transaction.objectStore('staking');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting staking info"));
                });
                
                const referrals = await new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['referrals'], 'readonly');
                    const store = transaction.objectStore('referrals');
                    const request = store.getAll();
                    
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(new Error("Error getting referrals"));
                });
                
                return {
                    blocks,
                    transactions,
                    wallets,
                    peers,
                    settings,
                    staking,
                    referrals,
                    version: 1,
                    exportedAt: Date.now()
                };
            }
            
            async importBlockchain(data) {
                // Validate data
                if (!data || !data.blocks || !data.transactions || !data.wallets || !data.settings) {
                    throw new Error("Invalid blockchain data");
                }
                
                // Clear existing data
                await this.clearDatabase();
                
                // Import data
                for (const block of data.blocks) {
                    await this.addBlock(block);
                }
                
                for (const tx of data.transactions) {
                    await this.addTransaction(tx);
                }
                
                for (const wallet of data.wallets) {
                    await this.saveWallet(wallet);
                }
                
                for (const peer of data.peers) {
                    await this.addPeer(peer);
                }
                
                for (const setting of Object.keys(data.settings)) {
                    this.settings[setting] = data.settings[setting];
                }
                
                await this.saveSettings();
                
                for (const stake of data.staking) {
                    await this.saveStakingInfo(stake);
                }
                
                for (const referral of data.referrals) {
                    await this.addReferral(referral);
                }
                
                // Reload the blockchain
                await this.loadBlockchain();
                
                return true;
            }
            
            async clearDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.deleteDatabase(this.dbName);
                    
                    request.onsuccess = () => {
                        this.db = null;
                        this.chain = [];
                        this.pendingTransactions = [];
                        this.peers = [];
                        resolve();
                    };
                    
                    request.onerror = () => {
                        reject(new Error("Error clearing database"));
                    };
                });
            }
            
            async getPaymentIntegrationCode() {
                return `
                    <!-- Kiira Coin Payment Integration -->
                    <script src="https://kiira-coin.example.com/payment.js"></script>
                    <div id="kiira-payment" 
                         data-address="${this.wallet.address}" 
                         data-amount="0.1" 
                         data-memo="Payment for services">
                    </div>
                    <script>
                        document.addEventListener('kiiraPaymentReceived', function(e) {
                            console.log('Payment received:', e.detail);
                            alert('Payment of ' + e.detail.amount + ' KRC received!');
                        });
                    </script>
                `;
            }
        }

        // UI Helper Functions
        function updateLoadingStatus(message) {
            const statusElement = document.getElementById('loadingStatus');
            if (statusElement) {
                statusElement.textContent = message;
            }
            console.log(message);
        }

        function showApp() {
            document.getElementById('loadingScreen').style.display = 'none';
            document.getElementById('appContent').style.display = 'block';
            
            // Initialize UI
            blockchain.updateUI();
            
            // Generate CAPTCHA
            blockchain.generateNewCaptcha();
        }

        function updateWalletInfo(address, balance) {
            document.getElementById('walletAddress').textContent = address;
            document.getElementById('walletBalance').textContent = balance.toFixed(8) + ' KRC';
        }

        function updateRecentTransactions(transactions) {
            const container = document.getElementById('recentTransactions');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (transactions.length === 0) {
                container.innerHTML = '<div class="transaction-item"><div class="transaction-details"><div>No recent transactions</div></div></div>';
                return;
            }
            
            transactions.forEach(tx => {
                const isIncoming = tx.to === blockchain.wallet.address;
                const amountClass = isIncoming ? 'positive' : 'negative';
                const amountPrefix = isIncoming ? '+' : '-';
                
                const txElement = document.createElement('div');
                txElement.className = 'transaction-item';
                txElement.innerHTML = `
                    <div class="transaction-details">
                        <div>${tx.memo || (isIncoming ? 'Received' : 'Sent')}</div>
                        <div class="transaction-amount ${amountClass}">${amountPrefix}${tx.amount.toFixed(8)} KRC</div>
                    </div>
                `;
                
                container.appendChild(txElement);
            });
        }

        function updateAllTransactions(transactions) {
            const container = document.getElementById('allTransactions');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (transactions.length === 0) {
                container.innerHTML = '<div class="transaction-item"><div class="transaction-details"><div>No transactions</div></div></div>';
                return;
            }
            
            transactions.forEach(tx => {
                const isIncoming = tx.to === blockchain.wallet.address;
                const amountClass = isIncoming ? 'positive' : 'negative';
                const amountPrefix = isIncoming ? '+' : '-';
                const otherParty = isIncoming ? 
                    (tx.from ? tx.from.substring(0, 8) + '...' + tx.from.substring(tx.from.length - 4) : 'System') : 
                    tx.to.substring(0, 8) + '...' + tx.to.substring(tx.to.length - 4);
                
                const txElement = document.createElement('div');
                txElement.className = 'transaction-item';
                txElement.innerHTML = `
                    <div class="transaction-details">
                        <div><strong>${tx.memo || (isIncoming ? 'Received from' : 'Sent to')} ${otherParty}</strong></div>
                        <div>${new Date(tx.timestamp).toLocaleString()}</div>
                        <div class="transaction-amount ${amountClass}">${amountPrefix}${tx.amount.toFixed(8)} KRC</div>
                    </div>
                `;
                
                container.appendChild(txElement);
            });
        }

        function updateAdminTransactions(transactions) {
            const container = document.getElementById('adminTransactionsList');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (transactions.length === 0) {
                container.innerHTML = '<div class="transaction-item"><div class="transaction-details"><div>No transactions</div></div></div>';
                return;
            }
            
            transactions.forEach(tx => {
                const isIncoming = tx.to === blockchain.wallet.address;
                const amountClass = isIncoming ? 'positive' : 'negative';
                const amountPrefix = isIncoming ? '+' : '-';
                const from = tx.from ? tx.from.substring(0, 8) + '...' + tx.from.substring(tx.from.length - 4) : 'System';
                const to = tx.to.substring(0, 8) + '...' + tx.to.substring(tx.to.length - 4);
                
                const txElement = document.createElement('div');
                txElement.className = 'transaction-item';
                txElement.innerHTML = `
                    <div class="transaction-details">
                        <div><strong>${tx.memo || 'Transaction'}</strong></div>
                        <div>From: ${from} → To: ${to}</div>
                        <div>${new Date(tx.timestamp).toLocaleString()}</div>
                        <div class="transaction-amount ${amountClass}">${amountPrefix}${tx.amount.toFixed(8)} KRC</div>
                    </div>
                `;
                
                container.appendChild(txElement);
            });
        }

        function updateStakingInfo(stakedAmount, rewards) {
            document.getElementById('stakedAmount').textContent = stakedAmount.toFixed(8);
            document.getElementById('stakingRewards').textContent = rewards.toFixed(8);
        }

        function updateValidatorNodes(validators) {
            const container = document.getElementById('validatorNodes');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (validators.length === 0) {
                container.innerHTML = '<div class="peer-item"><div>No active validators</div></div>';
                return;
            }
            
            validators.forEach(validator => {
                const isYou = validator.address === blockchain.wallet.address;
                const validatorElement = document.createElement('div');
                validatorElement.className = 'peer-item';
                validatorElement.innerHTML = `
                    <div>${validator.address.substring(0, 12)}...${isYou ? ' (You)' : ''}</div>
                    <div>${validator.amount.toFixed(8)} KRC staked</div>
                    <div class="status-indicator"></div>
                `;
                
                container.appendChild(validatorElement);
            });
        }

        function updateNetworkInfo(blockHeight, peersCount) {
            document.getElementById('blockHeight').textContent = blockHeight;
            document.getElementById('peersCount').textContent = peersCount;
            document.getElementById('networkStatus').textContent = peersCount > 0 ? 'Connected' : 'Disconnected';
        }

        function updateSupply(total, circulating) {
            document.getElementById('totalSupply').textContent = total.toLocaleString();
            document.getElementById('circulatingSupply').textContent = circulating.toFixed(8).toLocaleString();
        }

        function updateReferralInfo(referrals) {
            document.getElementById('totalReferrals').textContent = referrals.length;
            
            // Calculate total earnings from referrals
            let totalEarnings = 0;
            referrals.forEach(ref => {
                totalEarnings += blockchain.settings.totalSupply * (blockchain.settings.referralReward / 100);
            });
            
            document.getElementById('referralEarnings').textContent = totalEarnings.toFixed(8);
            
            // Update referral history
            const container = document.getElementById('referralHistory');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (referrals.length === 0) {
                container.innerHTML = '<div class="transaction-item"><div class="transaction-details"><div>No referrals yet</div></div></div>';
                return;
            }
            
            referrals.forEach(ref => {
                const refElement = document.createElement('div');
                refElement.className = 'transaction-item';
                refElement.innerHTML = `
                    <div class="transaction-details">
                        <div>Referred: ${ref.referred.substring(0, 12)}...</div>
                        <div>${new Date(ref.timestamp).toLocaleString()}</div>
                        <div class="transaction-amount positive">+${(blockchain.settings.totalSupply * (blockchain.settings.referralReward / 100)).toFixed(8)} KRC</div>
                    </div>
                `;
                
                container.appendChild(refElement);
            });
        }

        function updatePeersList(peers) {
            const container = document.getElementById('adminPeersList');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (peers.length === 0) {
                container.innerHTML = '<div class="peer-item"><div>No peers connected</div></div>';
                return;
            }
            
            peers.forEach(peer => {
                const peerElement = document.createElement('div');
                peerElement.className = 'peer-item';
                peerElement.innerHTML = `
                    <div>${peer.address.substring(0, 12)}...</div>
                    <div>Block: ${peer.height}</div>
                    <div class="status-indicator"></div>
                `;
                
                container.appendChild(peerElement);
            });
        }

        function updateOnlineTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            document.getElementById('onlineTime').textContent = minutes;
            document.getElementById('onlineEarnings').textContent = (minutes * blockchain.settings.onlineReward).toFixed(8);
        }

        function showNotification(message, isError = false) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = 'notification' + (isError ? ' error' : '');
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification('Copied to clipboard!');
            }).catch(err => {
                showNotification('Failed to copy: ' + err, true);
            });
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize blockchain
            window.blockchain = new KiiraCoinBlockchain();
            
            // Navigation
            document.querySelectorAll('.nav-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    const page = link.getAttribute('data-page');
                    
                    // Hide all pages
                    document.querySelectorAll('.page-content').forEach(p => {
                        p.classList.remove('active');
                    });
                    
                    // Show selected page
                    document.getElementById(`${page}-page`).classList.add('active');
                    
                    // Update active nav link
                    document.querySelectorAll('.nav-link').forEach(nav => {
                        nav.classList.remove('active');
                    });
                    link.classList.add('active');
                    
                    // Update sidebar active link
                    if (!link.closest('nav')) {
                        const navLink = document.querySelector(`nav a[data-page="${page}"]`);
                        if (navLink) navLink.classList.add('active');
                    }
                });
            });
            
            // Admin tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabId = tab.getAttribute('data-tab');
                    
                    // Set active tab
                    document.querySelectorAll('.tab').forEach(t => {
                        t.classList.remove('active');
                    });
                    tab.classList.add('active');
                    
                    // Show tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`${tabId}-tab`).classList.add('active');
                });
            });
            
            // Copy address
            document.getElementById('copyAddressBtn').addEventListener('click', () => {
                if (blockchain.wallet) {
                    copyToClipboard(blockchain.wallet.address);
                }
            });
            
            // Copy referral code
            document.getElementById('copyReferralBtn').addEventListener('click', () => {
                if (blockchain.referralCode) {
                    copyToClipboard(blockchain.referralCode);
                }
            });
            
            // Copy full referral link
            document.getElementById('copyFullReferralBtn').addEventListener('click', () => {
                const fullLink = `${window.location.origin}${window.location.pathname}?ref=${blockchain.referralCode}`;
                copyToClipboard(fullLink);
            });
            
            // Send funds modal
            document.getElementById('sendFundsBtn').addEventListener('click', () => {
                document.getElementById('sendFundsModal').style.display = 'flex';
            });
            
            document.getElementById('closeSendModalBtn').addEventListener('click', () => {
                document.getElementById('sendFundsModal').style.display = 'none';
            });
            
            // Send funds form
            document.getElementById('sendFundsForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const to = document.getElementById('recipientAddress').value;
                const amount = parseFloat(document.getElementById('sendAmount').value);
                const memo = document.getElementById('transactionMemo').value;
                
                if (!to.startsWith('KRC')) {
                    showNotification('Invalid Kiira Coin address', true);
                    return;
                }
                
                if (isNaN(amount) || amount <= 0) {
                    showNotification('Invalid amount', true);
                    return;
                }
                
                try {
                    await blockchain.createTransaction(blockchain.wallet.address, to, amount, memo);
                    showNotification('Transaction created successfully!');
                    document.getElementById('sendFundsModal').style.display = 'none';
                    document.getElementById('sendFundsForm').reset();
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Stake KRC
            document.getElementById('stakeBtn').addEventListener('click', async () => {
                const amount = parseFloat(document.getElementById('stakeAmount').value);
                
                if (isNaN(amount) {
                    showNotification('Please enter a valid amount', true);
                    return;
                }
                
                try {
                    const newStake = await blockchain.stake(amount);
                    showNotification(`Successfully staked ${amount.toFixed(8)} KRC. Total staked: ${newStake.toFixed(8)} KRC`);
                    document.getElementById('stakeAmount').value = '';
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Unstake KRC
            document.getElementById('unstakeBtn').addEventListener('click', async () => {
                const amount = parseFloat(document.getElementById('stakeAmount').value);
                
                if (isNaN(amount)) {
                    showNotification('Please enter a valid amount', true);
                    return;
                }
                
                try {
                    const newStake = await blockchain.unstake(amount);
                    showNotification(`Successfully unstaked ${amount.toFixed(8)} KRC. Total staked: ${newStake.toFixed(8)} KRC`);
                    document.getElementById('stakeAmount').value = '';
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Claim staking rewards
            document.getElementById('claimRewardsBtn')?.addEventListener('click', async () => {
                try {
                    const rewards = await blockchain.claimStakingRewards();
                    showNotification(`Claimed ${rewards.toFixed(8)} KRC in staking rewards!`);
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Submit CAPTCHA
            document.getElementById('submitCaptchaBtn').addEventListener('click', async () => {
                const solution = document.getElementById('captchaInput').value;
                const captchaText = document.getElementById('captchaText').textContent;
                
                if (!solution) {
                    showNotification('Please enter the CAPTCHA solution', true);
                    return;
                }
                
                // In a real implementation, we would validate the CAPTCHA
                // For demo purposes, we'll accept any solution
                try {
                    const reward = await blockchain.solveCaptcha(solution);
                    showNotification(`You earned ${reward.toFixed(8)} KRC for solving the CAPTCHA!`);
                    document.getElementById('captchaInput').value = '';
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Use referral code (from URL)
            const urlParams = new URLSearchParams(window.location.search);
            const refCode = urlParams.get('ref');
            
            if (refCode && blockchain && blockchain.wallet) {
                // Check if this wallet already used a referral code
                setTimeout(async () => {
                    try {
                        const referrer = await blockchain.useReferralCode(refCode);
                        showNotification(`You used referral code from ${referrer.substring(0, 8)}... and earned them rewards!`);
                    } catch (error) {
                        // Silent fail - not all users need to use a referral code
                        console.log("Referral code not used:", error.message);
                    }
                }, 3000);
            }
            
            // Admin: Update settings
            document.getElementById('blockchainSettingsForm')?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newSettings = {
                    blockReward: parseFloat(document.getElementById('blockReward').value),
                    stakeReward: parseFloat(document.getElementById('stakeReward').value),
                    referralReward: parseFloat(document.getElementById('referralReward').value),
                    captchaReward: parseFloat(document.getElementById('captchaRewardAdmin').value),
                    onlineReward: parseFloat(document.getElementById('onlineReward').value)
                };
                
                try {
                    await blockchain.updateBlockchainSettings(newSettings);
                    showNotification('Settings updated successfully!');
                    
                    // Update UI to reflect new settings
                    document.getElementById('captchaReward').textContent = newSettings.captchaReward.toFixed(8);
                    document.getElementById('onlineRewardRate').textContent = newSettings.onlineReward.toFixed(8);
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Admin: Update coin icon
            document.getElementById('updateCoinIconBtn')?.addEventListener('click', async () => {
                const fileInput = document.getElementById('coinIconUpload');
                const file = fileInput.files[0];
                
                if (!file) {
                    showNotification('Please select an image file', true);
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        await blockchain.updateCoinIcon(e.target.result);
                        showNotification('Coin icon updated successfully!');
                        fileInput.value = '';
                    } catch (error) {
                        showNotification(error.message, true);
                    }
                };
                reader.readAsDataURL(file);
            });
            
            // Admin: Export blockchain
            document.getElementById('exportBlockchainBtn')?.addEventListener('click', async () => {
                try {
                    const data = await blockchain.exportBlockchain();
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `kiira-coin-blockchain-${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    showNotification('Blockchain exported successfully!');
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Admin: Import blockchain
            document.getElementById('importBlockchainBtn')?.addEventListener('click', async () => {
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json';
                
                fileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            await blockchain.importBlockchain(data);
                            showNotification('Blockchain imported successfully!');
                            window.location.reload();
                        } catch (error) {
                            showNotification(error.message, true);
                        }
                    };
                    reader.readAsText(file);
                };
                
                fileInput.click();
            });
            
            // Admin: Save exchange integration
            document.getElementById('exchangeIntegrationForm')?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const newSettings = {
                    coinGeckoApiKey: document.getElementById('coinGeckoApiKey').value,
                    coinMarketCapApiKey: document.getElementById('coinMarketCapApiKey').value,
                    cryptoCompareApiKey: document.getElementById('cryptoCompareApiKey').value,
                    coinDescription: document.getElementById('coinDescription').value,
                    coinWebsite: document.getElementById('coinWebsite').value,
                    coinExplorer: document.getElementById('coinExplorer').value
                };
                
                try {
                    await blockchain.updateBlockchainSettings(newSettings);
                    showNotification('Exchange settings saved successfully!');
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Admin: Submit to listing sites
            document.getElementById('submitToListingBtn')?.addEventListener('click', async () => {
                showNotification('Listing information submitted to exchanges (simulated)');
            });
            
            // Admin: Copy integration code
            document.getElementById('copyIntegrationCodeBtn')?.addEventListener('click', async () => {
                try {
                    const code = await blockchain.getPaymentIntegrationCode();
                    copyToClipboard(code);
                } catch (error) {
                    showNotification(error.message, true);
                }
            });
            
            // Refresh transactions
            document.getElementById('refreshTransactionsBtn')?.addEventListener('click', async () => {
                await blockchain.updateTransactionsUI();
                showNotification('Transactions refreshed');
            });
            
            // View peers
            document.getElementById('viewPeersBtn')?.addEventListener('click', async () => {
                updatePeersList(blockchain.peers);
                document.querySelector('.tab[data-tab="peers"]').click();
            });
            
            // Broadcast message
            document.getElementById('broadcastMessageBtn')?.addEventListener('click', async () => {
                const message = prompt("Enter message to broadcast to network:");
                if (message) {
                    blockchain.broadcastPresence();
                    showNotification('Message broadcast to network');
                }
            });
            
            // Initialize referral link
            setTimeout(() => {
                if (blockchain.referralCode) {
                    document.getElementById('referralCode').textContent = blockchain.referralCode;
                    document.getElementById('fullReferralLink').textContent = 
                        `${window.location.origin}${window.location.pathname}?ref=${blockchain.referralCode}`;
                }
            }, 1000);
            
            // Load admin settings
            setTimeout(async () => {
                if (blockchain.isSuperAdmin) {
                    document.getElementById('blockReward').value = blockchain.settings.blockReward;
                    document.getElementById('stakeReward').value = blockchain.settings.stakeReward;
                    document.getElementById('referralReward').value = blockchain.settings.referralReward;
                    document.getElementById('captchaRewardAdmin').value = blockchain.settings.captchaReward;
                    document.getElementById('onlineReward').value = blockchain.settings.onlineReward;
                    
                    document.getElementById('coinDescription').value = blockchain.settings.coinDescription;
                    document.getElementById('coinWebsite').value = blockchain.settings.coinWebsite;
                    document.getElementById('coinExplorer').value = blockchain.settings.coinExplorer;
                    
                    // Load payment integration code
                    try {
                        const code = await blockchain.getPaymentIntegrationCode();
                        document.getElementById('paymentIntegrationCode').textContent = code;
                    } catch (error) {
                        console.error("Error loading payment code:", error);
                    }
                }
            }, 2000);
        });

        // Service Worker for offline functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js').then(registration => {
                    console.log('ServiceWorker registration successful');
                }).catch(err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>
